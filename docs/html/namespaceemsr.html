<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Polynomial: emsr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Polynomial
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceemsr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">emsr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemsr_1_1BairstowSolver.html">BairstowSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1divmod__t.html">divmod_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1has__imag__t.html">has_imag_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1has__imag__t_3_01Tp_00_01std_1_1void__t_3_01decltype_07std_1_1declval_3_01Tp_01_6_c8fe2aab4cea8d1a1147d770a127d10f.html">has_imag_t&lt; Tp, std::void_t&lt; decltype(std::declval&lt; Tp &amp; &gt;().imag())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1has__value__type__t.html">has_value_type_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1has__value__type__t_3_01Tp_00_01std_1_1void__t_3_01typename_01Tp_1_1value__type_01_4_01_4.html">has_value_type_t&lt; Tp, std::void_t&lt; typename Tp::value_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemsr_1_1JenkinsTraubSolver.html">JenkinsTraubSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemsr_1_1JenkinsTraubSolver_3_01std_1_1complex_3_01Real_01_4_01_4.html">JenkinsTraubSolver&lt; std::complex&lt; Real &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemsr_1_1LaguerreSolver.html">LaguerreSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1modf__t.html">modf_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense polynomial class with a contiguous array of coefficients. The coefficients are lowest-order first:  <a href="classemsr_1_1Polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemsr_1_1QuadraticSolver.html">QuadraticSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemsr_1_1RationalPolynomial.html">RationalPolynomial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1real__type.html">real_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1real__type_3_01Polynomial_3_01Tp_01_4_01_4.html">real_type&lt; Polynomial&lt; Tp &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1real__type_3_01std_1_1complex_3_01Tp_01_4_01_4.html">real_type&lt; std::complex&lt; Tp &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemsr_1_1Solution.html">Solution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab11381c9f569c2c3d6ea24d63fbca345"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ab11381c9f569c2c3d6ea24d63fbca345">intmaxquot_t</a> = <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt; std::intmax_t &gt;</td></tr>
<tr class="separator:ab11381c9f569c2c3d6ea24d63fbca345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6dbac674a6a512a5cbd904d8e6ba10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a7c6dbac674a6a512a5cbd904d8e6ba10">llquot_t</a> = <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt; long long int &gt;</td></tr>
<tr class="separator:a7c6dbac674a6a512a5cbd904d8e6ba10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858cd87acb34606af0ecef15aaae7db9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a858cd87acb34606af0ecef15aaae7db9">lquot_t</a> = <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt; long int &gt;</td></tr>
<tr class="separator:a858cd87acb34606af0ecef15aaae7db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddbab71ecfa506ad878ac9e60153a02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a3ddbab71ecfa506ad878ac9e60153a02">quot_t</a> = <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt; int &gt;</td></tr>
<tr class="separator:a3ddbab71ecfa506ad878ac9e60153a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ec0ebded7be3a1b57643770c87e413"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a02ec0ebded7be3a1b57643770c87e413"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a02ec0ebded7be3a1b57643770c87e413">real_type_t</a> = typename <a class="el" href="structemsr_1_1real__type.html">real_type</a>&lt; Tp &gt;::type</td></tr>
<tr class="separator:a02ec0ebded7be3a1b57643770c87e413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7689491743dc22cc5ad3ed13245199"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a8e7689491743dc22cc5ad3ed13245199">squot_t</a> = <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt; short int &gt;</td></tr>
<tr class="separator:a8e7689491743dc22cc5ad3ed13245199"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a782d36096e8467b4a45a9dc2f89355b2"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a782d36096e8467b4a45a9dc2f89355b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">abs</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x)</td></tr>
<tr class="separator:a782d36096e8467b4a45a9dc2f89355b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe4f64b8e546b29054514e013560ea0"><td class="memTemplParams" colspan="2">template&lt;typename Real , typename Iter &gt; </td></tr>
<tr class="memitem:affe4f64b8e546b29054514e013560ea0"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#affe4f64b8e546b29054514e013560ea0">cubic</a> (const Iter &amp;CC)</td></tr>
<tr class="memdesc:affe4f64b8e546b29054514e013560ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the roots of a cubic equation of the form:  <a href="namespaceemsr.html#affe4f64b8e546b29054514e013560ea0">More...</a><br /></td></tr>
<tr class="separator:affe4f64b8e546b29054514e013560ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78d9f421df742cad9c10eb3c753f7b8"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ad78d9f421df742cad9c10eb3c753f7b8"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ad78d9f421df742cad9c10eb3c753f7b8">cubic</a> (Real c0, Real c1, Real c2, Real c3)</td></tr>
<tr class="separator:ad78d9f421df742cad9c10eb3c753f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d92c91e21caca3557589683df6650c4"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a5d92c91e21caca3557589683df6650c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a5d92c91e21caca3557589683df6650c4">divmod</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;num, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;den, <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;quo, <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;rem)</td></tr>
<tr class="separator:a5d92c91e21caca3557589683df6650c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef21b65838fd0c04b66d44127996289"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t SizeN, std::size_t SizeD&gt; </td></tr>
<tr class="memitem:acef21b65838fd0c04b66d44127996289"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1divmod__t.html">divmod_t</a>&lt; Tp, SizeN, SizeD &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#acef21b65838fd0c04b66d44127996289">divmod</a> (<a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeN &gt; num, <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeD &gt; den)</td></tr>
<tr class="separator:acef21b65838fd0c04b66d44127996289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb382de8e6aff992729a230f89525101"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#abb382de8e6aff992729a230f89525101">exp10f</a> (float x)</td></tr>
<tr class="separator:abb382de8e6aff992729a230f89525101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624fb5e5eea1d39f8d701c1d62cce358"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a624fb5e5eea1d39f8d701c1d62cce358">exp10log</a> (double x)</td></tr>
<tr class="separator:a624fb5e5eea1d39f8d701c1d62cce358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a7f2674537e3b49666a7ded50d1db8"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a46a7f2674537e3b49666a7ded50d1db8">exp10logl</a> (long double x)</td></tr>
<tr class="separator:a46a7f2674537e3b49666a7ded50d1db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc0119932c1b3a45cba25185cb951a7"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a3fc0119932c1b3a45cba25185cb951a7"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a3fc0119932c1b3a45cba25185cb951a7">expm1</a> (const std::complex&lt; Tp &gt; &amp;z)</td></tr>
<tr class="separator:a3fc0119932c1b3a45cba25185cb951a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc8058fc99599e5fcdd1b70250c84ac"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a2bc8058fc99599e5fcdd1b70250c84ac"><td class="memTemplItemLeft" align="right" valign="top">Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a2bc8058fc99599e5fcdd1b70250c84ac">expm1</a> (Tp x)</td></tr>
<tr class="separator:a2bc8058fc99599e5fcdd1b70250c84ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733f95a5b7d092ab0423af88d1bb6768"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a733f95a5b7d092ab0423af88d1bb6768"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a733f95a5b7d092ab0423af88d1bb6768">fma</a> (const std::complex&lt; Tp &gt; &amp;a, const std::complex&lt; Tp &gt; &amp;z, const std::complex&lt; Tp &gt; &amp;b)</td></tr>
<tr class="separator:a733f95a5b7d092ab0423af88d1bb6768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d471bddd0d8162bc3bed84f4930312"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:ae9d471bddd0d8162bc3bed84f4930312"><td class="memTemplItemLeft" align="right" valign="top">Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ae9d471bddd0d8162bc3bed84f4930312">fma</a> (Tp a, Tp b, Tp c)</td></tr>
<tr class="separator:ae9d471bddd0d8162bc3bed84f4930312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd7b690135a53730e52d903bd2b87f5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#adcd7b690135a53730e52d903bd2b87f5">frexp</a> (double value)</td></tr>
<tr class="separator:adcd7b690135a53730e52d903bd2b87f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebac42aafb021bf490f4cd15be2e2c47"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aebac42aafb021bf490f4cd15be2e2c47">frexp</a> (float value)</td></tr>
<tr class="separator:aebac42aafb021bf490f4cd15be2e2c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d24b7cd96bd605e04fdeaff84e5561d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a6d24b7cd96bd605e04fdeaff84e5561d">frexp</a> (long double value)</td></tr>
<tr class="separator:a6d24b7cd96bd605e04fdeaff84e5561d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73997c8089c4b9fc4225bb2b91e80d93"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a73997c8089c4b9fc4225bb2b91e80d93">frexpf</a> (float value)</td></tr>
<tr class="separator:a73997c8089c4b9fc4225bb2b91e80d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25ac2cbc0c43972d690d3e5375363bf"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#af25ac2cbc0c43972d690d3e5375363bf">frexpl</a> (long double value)</td></tr>
<tr class="separator:af25ac2cbc0c43972d690d3e5375363bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fe740b04b1f58f0cafe9042b5a380b"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:af9fe740b04b1f58f0cafe9042b5a380b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceemsr.html#a02ec0ebded7be3a1b57643770c87e413">real_type_t</a>&lt; <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#af9fe740b04b1f58f0cafe9042b5a380b">get_scale</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;poly)</td></tr>
<tr class="separator:af9fe740b04b1f58f0cafe9042b5a380b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bdedf1c9d27acc3695f86d226ca149"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:af8bdedf1c9d27acc3695f86d226ca149"><td class="memTemplItemLeft" align="right" valign="top">decltype(std::abs(Tp()))&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#af8bdedf1c9d27acc3695f86d226ca149">get_scale</a> (const Tp &amp;x)</td></tr>
<tr class="separator:af8bdedf1c9d27acc3695f86d226ca149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76e856347b8d4dc1991d8aad92199f0"><td class="memTemplParams" colspan="2">template&lt;typename ArgT , typename Coef0 , typename... Coef&gt; </td></tr>
<tr class="memitem:ad76e856347b8d4dc1991d8aad92199f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::conditional_t&lt; std::is_integral&lt; ArgT &gt;::value, double, ArgT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ad76e856347b8d4dc1991d8aad92199f0">horner</a> (ArgT x, Coef0 c0, Coef... c)</td></tr>
<tr class="separator:ad76e856347b8d4dc1991d8aad92199f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155d146e57554633b51b21e4681ce000"><td class="memTemplParams" colspan="2">template&lt;typename ArgT , typename Coef0 &gt; </td></tr>
<tr class="memitem:a155d146e57554633b51b21e4681ce000"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::conditional_t&lt; std::is_integral&lt; ArgT &gt;::value, double, ArgT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a155d146e57554633b51b21e4681ce000">horner</a> (ArgT, Coef0 c0)</td></tr>
<tr class="separator:a155d146e57554633b51b21e4681ce000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381a03247643fc05de000c9d2ccbbe12"><td class="memTemplParams" colspan="2">template&lt;typename ArgT , typename Coef1 , typename Coef0 &gt; </td></tr>
<tr class="memitem:a381a03247643fc05de000c9d2ccbbe12"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::conditional_t&lt; std::is_integral&lt; ArgT &gt;::value, double, ArgT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a381a03247643fc05de000c9d2ccbbe12">horner_big_end</a> (ArgT x, Coef1 c1, Coef0 c0)</td></tr>
<tr class="separator:a381a03247643fc05de000c9d2ccbbe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc246a38d5dc59a528e6fc7ec3d38b5a"><td class="memTemplParams" colspan="2">template&lt;typename ArgT , typename CoefN , typename CoefNm1 , typename... Coef&gt; </td></tr>
<tr class="memitem:acc246a38d5dc59a528e6fc7ec3d38b5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::conditional_t&lt; std::is_integral&lt; ArgT &gt;::value, double, ArgT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#acc246a38d5dc59a528e6fc7ec3d38b5a">horner_big_end</a> (ArgT x, CoefN cn, CoefNm1 cnm1, Coef... c)</td></tr>
<tr class="separator:acc246a38d5dc59a528e6fc7ec3d38b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55de120e4dc9c5c34075279bdf43d17c"><td class="memTemplParams" colspan="2">template&lt;typename ArgT , typename Coef0 &gt; </td></tr>
<tr class="memitem:a55de120e4dc9c5c34075279bdf43d17c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::conditional_t&lt; std::is_integral&lt; ArgT &gt;::value, double, ArgT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a55de120e4dc9c5c34075279bdf43d17c">horner_big_end</a> (ArgT, Coef0 c0)</td></tr>
<tr class="separator:a55de120e4dc9c5c34075279bdf43d17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ddc0cda81a11ab065e5caae9e0907a"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a79ddc0cda81a11ab065e5caae9e0907a"><td class="memTemplItemLeft" align="right" valign="top">constexpr Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a79ddc0cda81a11ab065e5caae9e0907a">imag</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x)</td></tr>
<tr class="separator:a79ddc0cda81a11ab065e5caae9e0907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0802472e214876defe3080bce9fe631"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#ab11381c9f569c2c3d6ea24d63fbca345">intmaxquot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#af0802472e214876defe3080bce9fe631">intmaxquot</a> (std::intmax_t x, std::intmax_t y)</td></tr>
<tr class="separator:af0802472e214876defe3080bce9fe631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad500d5a09de89975430355fd46c9be25"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ad500d5a09de89975430355fd46c9be25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ad500d5a09de89975430355fd46c9be25">is_valid</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x)</td></tr>
<tr class="separator:ad500d5a09de89975430355fd46c9be25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272468eace328b906a032e5273588040"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#a7c6dbac674a6a512a5cbd904d8e6ba10">llquot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a272468eace328b906a032e5273588040">llquot</a> (long long int numer, long long int denom)</td></tr>
<tr class="separator:a272468eace328b906a032e5273588040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ccee3147194cc2f4f937af47adddab"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ad0ccee3147194cc2f4f937af47adddab">log</a> (double base, double x)</td></tr>
<tr class="separator:ad0ccee3147194cc2f4f937af47adddab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fd9693dd2a6a63599013938c3a76f7"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a14fd9693dd2a6a63599013938c3a76f7"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a14fd9693dd2a6a63599013938c3a76f7">log1p</a> (const std::complex&lt; Tp &gt; &amp;z)</td></tr>
<tr class="separator:a14fd9693dd2a6a63599013938c3a76f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118130fce7fc0ef3f1231bf0c6a21259"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a118130fce7fc0ef3f1231bf0c6a21259"><td class="memTemplItemLeft" align="right" valign="top">Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a118130fce7fc0ef3f1231bf0c6a21259">log1p</a> (Tp x)</td></tr>
<tr class="separator:a118130fce7fc0ef3f1231bf0c6a21259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8ccf5fc5827ad75cc4a78e0af5170f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#abc8ccf5fc5827ad75cc4a78e0af5170f">logf</a> (float base, float x)</td></tr>
<tr class="separator:abc8ccf5fc5827ad75cc4a78e0af5170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00236804cfcde3d04cae74c577acc4af"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a00236804cfcde3d04cae74c577acc4af">logl</a> (long double base, long double x)</td></tr>
<tr class="separator:a00236804cfcde3d04cae74c577acc4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c24d6521dc8d94c2f7c0b7e1f01b38"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#a858cd87acb34606af0ecef15aaae7db9">lquot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a23c24d6521dc8d94c2f7c0b7e1f01b38">lquot</a> (long int numer, long int denom)</td></tr>
<tr class="separator:a23c24d6521dc8d94c2f7c0b7e1f01b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b35da26edac14bb58a005527b989a89"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a5b35da26edac14bb58a005527b989a89">modf</a> (double value)</td></tr>
<tr class="separator:a5b35da26edac14bb58a005527b989a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01b1428c15d190dfe08aa38279f0db0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ad01b1428c15d190dfe08aa38279f0db0">modf</a> (float value)</td></tr>
<tr class="separator:ad01b1428c15d190dfe08aa38279f0db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a464b7b372773df38dea93734e02be8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a6a464b7b372773df38dea93734e02be8">modf</a> (long double value)</td></tr>
<tr class="separator:a6a464b7b372773df38dea93734e02be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377018ccb1391c355b93a196f0ad8abd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a377018ccb1391c355b93a196f0ad8abd">modff</a> (float value)</td></tr>
<tr class="separator:a377018ccb1391c355b93a196f0ad8abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed6e215d68b190d8d1bb41e74067f27"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a5ed6e215d68b190d8d1bb41e74067f27">modfl</a> (long double value)</td></tr>
<tr class="separator:a5ed6e215d68b190d8d1bb41e74067f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af260f11b5410b8f8c2bfffd4e66ac74f"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#af260f11b5410b8f8c2bfffd4e66ac74f">nan</a> ()</td></tr>
<tr class="separator:af260f11b5410b8f8c2bfffd4e66ac74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087f46f5fadc56390bf152e5b32c146b"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a087f46f5fadc56390bf152e5b32c146b">nanf</a> ()</td></tr>
<tr class="separator:a087f46f5fadc56390bf152e5b32c146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b28319a5e2e896cb29b98b60b9383f"><td class="memItemLeft" align="right" valign="top">constexpr long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ab7b28319a5e2e896cb29b98b60b9383f">nanl</a> ()</td></tr>
<tr class="separator:ab7b28319a5e2e896cb29b98b60b9383f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a330b4ef9bcc0f45e8fd412567322e"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a16a330b4ef9bcc0f45e8fd412567322e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a16a330b4ef9bcc0f45e8fd412567322e">operator!=</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pa, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pb)</td></tr>
<tr class="separator:a16a330b4ef9bcc0f45e8fd412567322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52e42498f67025febd9075ad75b0645"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ad52e42498f67025febd9075ad75b0645"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ad52e42498f67025febd9075ad75b0645">operator!=</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:ad52e42498f67025febd9075ad75b0645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65037c6f423a051e29798d1039949525"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a65037c6f423a051e29798d1039949525"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a65037c6f423a051e29798d1039949525">operator!=</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const std::complex&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a65037c6f423a051e29798d1039949525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fc1800f8665163ddee970a134d64bb"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ab7fc1800f8665163ddee970a134d64bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ab7fc1800f8665163ddee970a134d64bb">operator!=</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, Real y)</td></tr>
<tr class="separator:ab7fc1800f8665163ddee970a134d64bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d5ac2d244366ee3e69ae9b6f1e7b0c"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:a09d5ac2d244366ee3e69ae9b6f1e7b0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a09d5ac2d244366ee3e69ae9b6f1e7b0c">operator!=</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;pa, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;pb)</td></tr>
<tr class="separator:a09d5ac2d244366ee3e69ae9b6f1e7b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72376979bbd5b2bb27e73e4ea38bf5c8"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t SizeA, std::size_t SizeB&gt; </td></tr>
<tr class="memitem:a72376979bbd5b2bb27e73e4ea38bf5c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a72376979bbd5b2bb27e73e4ea38bf5c8">operator!=</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeA &gt; &amp;pa, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeB &gt; &amp;pb)</td></tr>
<tr class="separator:a72376979bbd5b2bb27e73e4ea38bf5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbf4dea4cebcd849d6c9d6811289073"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a7dbf4dea4cebcd849d6c9d6811289073"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a7dbf4dea4cebcd849d6c9d6811289073">operator!=</a> (const std::complex&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a7dbf4dea4cebcd849d6c9d6811289073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca6592331d19bfa53c432a5ea9f442e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a1ca6592331d19bfa53c432a5ea9f442e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a1ca6592331d19bfa53c432a5ea9f442e">operator!=</a> (Real x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a1ca6592331d19bfa53c432a5ea9f442e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd25852afa794395ff3c829b2eb023b"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:adbd25852afa794395ff3c829b2eb023b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()/Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#adbd25852afa794395ff3c829b2eb023b">operator%</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pa, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;pb)</td></tr>
<tr class="separator:adbd25852afa794395ff3c829b2eb023b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9775373361a9859b3504c2d9c6bfbb"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:aed9775373361a9859b3504c2d9c6bfbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()/Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aed9775373361a9859b3504c2d9c6bfbb">operator%</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;poly, const Up &amp;x)</td></tr>
<tr class="separator:aed9775373361a9859b3504c2d9c6bfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b83fde2c334cc77b0a97884ce2ffcd"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:ac1b83fde2c334cc77b0a97884ce2ffcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()/Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ac1b83fde2c334cc77b0a97884ce2ffcd">operator%</a> (const Tp &amp;x, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;poly)</td></tr>
<tr class="separator:ac1b83fde2c334cc77b0a97884ce2ffcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf765562606a0b8a941a5cb24ecd1f2e"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </td></tr>
<tr class="memitem:acf765562606a0b8a941a5cb24ecd1f2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, <a class="el" href="structemsr_1_1divmod__t.html">divmod_t</a>&lt; Tp, SizeP, SizeQ &gt;::SizeRem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#acf765562606a0b8a941a5cb24ecd1f2e">operator%</a> (<a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt; P, <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt; Q)</td></tr>
<tr class="separator:acf765562606a0b8a941a5cb24ecd1f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8744ef4ccdde86f46197a7da33e0053"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:aa8744ef4ccdde86f46197a7da33e0053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp() *Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aa8744ef4ccdde86f46197a7da33e0053">operator*</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pa, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;pb)</td></tr>
<tr class="separator:aa8744ef4ccdde86f46197a7da33e0053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a45baf6731916a2509a6c7cecc7fe79"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:a2a45baf6731916a2509a6c7cecc7fe79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp() *Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a2a45baf6731916a2509a6c7cecc7fe79">operator*</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;poly, const Up &amp;x)</td></tr>
<tr class="separator:a2a45baf6731916a2509a6c7cecc7fe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabff597754fb0244c190e91bb6f26fd4"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aabff597754fb0244c190e91bb6f26fd4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aabff597754fb0244c190e91bb6f26fd4">operator*</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:aabff597754fb0244c190e91bb6f26fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d3aa3a28f77da8940fac42aff11d4"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a4a8d3aa3a28f77da8940fac42aff11d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a4a8d3aa3a28f77da8940fac42aff11d4">operator*</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const std::complex&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a4a8d3aa3a28f77da8940fac42aff11d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a39231a5577174cc0db572a71551596"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a8a39231a5577174cc0db572a71551596"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a8a39231a5577174cc0db572a71551596">operator*</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, Real y)</td></tr>
<tr class="separator:a8a39231a5577174cc0db572a71551596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a7b09b354edaf1a67833b613a29fe7"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:a16a7b09b354edaf1a67833b613a29fe7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a16a7b09b354edaf1a67833b613a29fe7">operator*</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;poly, const Tp &amp;x)</td></tr>
<tr class="separator:a16a7b09b354edaf1a67833b613a29fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5909d8b89e4fe1928b93a5be6f1058c"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:af5909d8b89e4fe1928b93a5be6f1058c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#af5909d8b89e4fe1928b93a5be6f1058c">operator*</a> (const std::complex&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:af5909d8b89e4fe1928b93a5be6f1058c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685115a02fab5426320cb39202dc2103"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:a685115a02fab5426320cb39202dc2103"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp() *Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a685115a02fab5426320cb39202dc2103">operator*</a> (const Tp &amp;x, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;poly)</td></tr>
<tr class="separator:a685115a02fab5426320cb39202dc2103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c299a6a1f67eea19cdd8efa945320c"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:a15c299a6a1f67eea19cdd8efa945320c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a15c299a6a1f67eea19cdd8efa945320c">operator*</a> (const Tp &amp;x, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;poly)</td></tr>
<tr class="separator:a15c299a6a1f67eea19cdd8efa945320c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532d30a3725f3b9f83ff768947a20d2b"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a532d30a3725f3b9f83ff768947a20d2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a532d30a3725f3b9f83ff768947a20d2b">operator*</a> (Real x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a532d30a3725f3b9f83ff768947a20d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee7a79333f51a0708b40099b86c3d68"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </td></tr>
<tr class="memitem:aaee7a79333f51a0708b40099b86c3d68"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP+SizeQ - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aaee7a79333f51a0708b40099b86c3d68">operator*</a> (<a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt; P, <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt; Q)</td></tr>
<tr class="separator:aaee7a79333f51a0708b40099b86c3d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0950a02906dfd97c4e53b76021cdf79"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:ac0950a02906dfd97c4e53b76021cdf79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()+Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ac0950a02906dfd97c4e53b76021cdf79">operator+</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pa, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;pb)</td></tr>
<tr class="separator:ac0950a02906dfd97c4e53b76021cdf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033506a4ee4ccdeec1d2d106715d063d"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:a033506a4ee4ccdeec1d2d106715d063d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()+Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a033506a4ee4ccdeec1d2d106715d063d">operator+</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;poly, const Up &amp;x)</td></tr>
<tr class="separator:a033506a4ee4ccdeec1d2d106715d063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc7606f0dde0b46384b29879ee9537e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0cc7606f0dde0b46384b29879ee9537e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a0cc7606f0dde0b46384b29879ee9537e">operator+</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x)</td></tr>
<tr class="separator:a0cc7606f0dde0b46384b29879ee9537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b70158ac63e2c4ff91a23f962b10597"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a9b70158ac63e2c4ff91a23f962b10597"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a9b70158ac63e2c4ff91a23f962b10597">operator+</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a9b70158ac63e2c4ff91a23f962b10597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1d6fe31e0864c5336cece2a58cdb44"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a8f1d6fe31e0864c5336cece2a58cdb44"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a8f1d6fe31e0864c5336cece2a58cdb44">operator+</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const std::complex&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a8f1d6fe31e0864c5336cece2a58cdb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae0ae20027dc5a2044b9d6dd9534227"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:afae0ae20027dc5a2044b9d6dd9534227"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#afae0ae20027dc5a2044b9d6dd9534227">operator+</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, Real y)</td></tr>
<tr class="separator:afae0ae20027dc5a2044b9d6dd9534227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f9c77d362616a5b91370c34a78fa6b"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:a15f9c77d362616a5b91370c34a78fa6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a15f9c77d362616a5b91370c34a78fa6b">operator+</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;poly, const Tp &amp;x)</td></tr>
<tr class="separator:a15f9c77d362616a5b91370c34a78fa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc873d61e52834d706fdca83bfbb4c"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </td></tr>
<tr class="memitem:a63fc873d61e52834d706fdca83bfbb4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, std::max(SizeP, SizeQ)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a63fc873d61e52834d706fdca83bfbb4c">operator+</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt; &amp;P, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt; &amp;Q)</td></tr>
<tr class="separator:a63fc873d61e52834d706fdca83bfbb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf385890f1a6fa020b1773ba53d00310"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:adf385890f1a6fa020b1773ba53d00310"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#adf385890f1a6fa020b1773ba53d00310">operator+</a> (const std::complex&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:adf385890f1a6fa020b1773ba53d00310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403f7be9f19b8cd47e718d94ec8659c1"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:a403f7be9f19b8cd47e718d94ec8659c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()+Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a403f7be9f19b8cd47e718d94ec8659c1">operator+</a> (const Tp &amp;x, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;poly)</td></tr>
<tr class="separator:a403f7be9f19b8cd47e718d94ec8659c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69132b96f7e9a2ae23613329b9bc2c43"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:a69132b96f7e9a2ae23613329b9bc2c43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a69132b96f7e9a2ae23613329b9bc2c43">operator+</a> (const Tp &amp;x, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;poly)</td></tr>
<tr class="separator:a69132b96f7e9a2ae23613329b9bc2c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab946e0e685c1304a6e9e249e837061a4"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ab946e0e685c1304a6e9e249e837061a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ab946e0e685c1304a6e9e249e837061a4">operator+</a> (Real x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:ab946e0e685c1304a6e9e249e837061a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843a89e4dfe80c1548a59e70ac2f191c"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:a843a89e4dfe80c1548a59e70ac2f191c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp() - Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a843a89e4dfe80c1548a59e70ac2f191c">operator-</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pa, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;pb)</td></tr>
<tr class="separator:a843a89e4dfe80c1548a59e70ac2f191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaf3b7d364a2f3d94396ea631702313"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:afeaf3b7d364a2f3d94396ea631702313"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp() - Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#afeaf3b7d364a2f3d94396ea631702313">operator-</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;poly, const Up &amp;x)</td></tr>
<tr class="separator:afeaf3b7d364a2f3d94396ea631702313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434a04338777c51fec03a803df64f1ea"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a434a04338777c51fec03a803df64f1ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a434a04338777c51fec03a803df64f1ea">operator-</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x)</td></tr>
<tr class="separator:a434a04338777c51fec03a803df64f1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab571b1b9099153a1aba906a25e238dfa"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ab571b1b9099153a1aba906a25e238dfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ab571b1b9099153a1aba906a25e238dfa">operator-</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:ab571b1b9099153a1aba906a25e238dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb04a325d56ca7ee1ee8b4ced1a15800"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:abb04a325d56ca7ee1ee8b4ced1a15800"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#abb04a325d56ca7ee1ee8b4ced1a15800">operator-</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const std::complex&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:abb04a325d56ca7ee1ee8b4ced1a15800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0395812f51330c8690936c11f9a526"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a1d0395812f51330c8690936c11f9a526"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a1d0395812f51330c8690936c11f9a526">operator-</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, Real y)</td></tr>
<tr class="separator:a1d0395812f51330c8690936c11f9a526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772477b7ef831939a073b26edba74ceb"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:a772477b7ef831939a073b26edba74ceb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a772477b7ef831939a073b26edba74ceb">operator-</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;poly, const Tp &amp;x)</td></tr>
<tr class="separator:a772477b7ef831939a073b26edba74ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f90e5b35bca2c0e3c01acd3a2e454ae"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </td></tr>
<tr class="memitem:a7f90e5b35bca2c0e3c01acd3a2e454ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, std::max(SizeP, SizeQ)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a7f90e5b35bca2c0e3c01acd3a2e454ae">operator-</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt; &amp;P, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt; &amp;Q)</td></tr>
<tr class="separator:a7f90e5b35bca2c0e3c01acd3a2e454ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e20c39abb723a3c8a6d6c81ad5b681"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:af0e20c39abb723a3c8a6d6c81ad5b681"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#af0e20c39abb723a3c8a6d6c81ad5b681">operator-</a> (const std::complex&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:af0e20c39abb723a3c8a6d6c81ad5b681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a0879331fef9a4b9af6175f8e938f"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:a615a0879331fef9a4b9af6175f8e938f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp() - Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a615a0879331fef9a4b9af6175f8e938f">operator-</a> (const Tp &amp;x, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;poly)</td></tr>
<tr class="separator:a615a0879331fef9a4b9af6175f8e938f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3d0d3e888b0ad30918f438971124cb"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:aac3d0d3e888b0ad30918f438971124cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aac3d0d3e888b0ad30918f438971124cb">operator-</a> (const Tp &amp;x, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;poly)</td></tr>
<tr class="separator:aac3d0d3e888b0ad30918f438971124cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016df2328f39b176fcd5c22f612497a0"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a016df2328f39b176fcd5c22f612497a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a016df2328f39b176fcd5c22f612497a0">operator-</a> (Real x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a016df2328f39b176fcd5c22f612497a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aabca53f527d2b4c2682e178ed8cbf"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:a20aabca53f527d2b4c2682e178ed8cbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()/Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a20aabca53f527d2b4c2682e178ed8cbf">operator/</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pa, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;pb)</td></tr>
<tr class="separator:a20aabca53f527d2b4c2682e178ed8cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac256fc3b7f1798a6b95a612fd291bb4f"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:ac256fc3b7f1798a6b95a612fd291bb4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()/Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ac256fc3b7f1798a6b95a612fd291bb4f">operator/</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;poly, const Up &amp;x)</td></tr>
<tr class="separator:ac256fc3b7f1798a6b95a612fd291bb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae74c8d59cd3b187fc89692d21fb6aec"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aae74c8d59cd3b187fc89692d21fb6aec"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aae74c8d59cd3b187fc89692d21fb6aec">operator/</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:aae74c8d59cd3b187fc89692d21fb6aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b53a2571ed1de735c01abe73604730f"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a5b53a2571ed1de735c01abe73604730f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a5b53a2571ed1de735c01abe73604730f">operator/</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const std::complex&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a5b53a2571ed1de735c01abe73604730f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddf836180b255c273560c94ba78aa3e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a1ddf836180b255c273560c94ba78aa3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a1ddf836180b255c273560c94ba78aa3e">operator/</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, Real y)</td></tr>
<tr class="separator:a1ddf836180b255c273560c94ba78aa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62b909a4cfa67f2023ae82816b150ba"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:ae62b909a4cfa67f2023ae82816b150ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ae62b909a4cfa67f2023ae82816b150ba">operator/</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;poly, const Tp &amp;x)</td></tr>
<tr class="separator:ae62b909a4cfa67f2023ae82816b150ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0151e61717cae6662ea239b3a2433d89"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0151e61717cae6662ea239b3a2433d89"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a0151e61717cae6662ea239b3a2433d89">operator/</a> (const std::complex&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a0151e61717cae6662ea239b3a2433d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65421cfb10c2b328c5f6fe32394e105a"><td class="memTemplParams" colspan="2">template&lt;typename Tp , typename Up &gt; </td></tr>
<tr class="memitem:a65421cfb10c2b328c5f6fe32394e105a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; decltype(Tp()/Up())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a65421cfb10c2b328c5f6fe32394e105a">operator/</a> (const Tp &amp;x, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;poly)</td></tr>
<tr class="separator:a65421cfb10c2b328c5f6fe32394e105a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e523c350964ac38101a06d45484f65a"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0e523c350964ac38101a06d45484f65a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a0e523c350964ac38101a06d45484f65a">operator/</a> (Real x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a0e523c350964ac38101a06d45484f65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1d926a861da466e01effa736d8a67f"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </td></tr>
<tr class="memitem:a5e1d926a861da466e01effa736d8a67f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, <a class="el" href="structemsr_1_1divmod__t.html">divmod_t</a>&lt; Tp, SizeP, SizeQ &gt;::SizeQuo &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a5e1d926a861da466e01effa736d8a67f">operator/</a> (<a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt; P, <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt; Q)</td></tr>
<tr class="separator:a5e1d926a861da466e01effa736d8a67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348aa4c91f5141addb4006973a934bd7"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a348aa4c91f5141addb4006973a934bd7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a348aa4c91f5141addb4006973a934bd7">operator&lt;</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a348aa4c91f5141addb4006973a934bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651793a53daa6800efcd4d711b0dc8bf"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a651793a53daa6800efcd4d711b0dc8bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a651793a53daa6800efcd4d711b0dc8bf">operator&lt;</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const std::complex&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a651793a53daa6800efcd4d711b0dc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1414352fb5db1523b704004efe6491e8"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a1414352fb5db1523b704004efe6491e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a1414352fb5db1523b704004efe6491e8">operator&lt;</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, Real y)</td></tr>
<tr class="separator:a1414352fb5db1523b704004efe6491e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cee564d7a746ef2606609a28f90fa1"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a59cee564d7a746ef2606609a28f90fa1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a59cee564d7a746ef2606609a28f90fa1">operator&lt;</a> (const std::complex&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a59cee564d7a746ef2606609a28f90fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f75a43bf27f6102ddef9ce53dfe4ab"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a33f75a43bf27f6102ddef9ce53dfe4ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a33f75a43bf27f6102ddef9ce53dfe4ab">operator&lt;</a> (Real x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a33f75a43bf27f6102ddef9ce53dfe4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926f40da1c865e89a91b9f151c1e3346"><td class="memTemplParams" colspan="2">template&lt;typename Char , typename Real &gt; </td></tr>
<tr class="memitem:a926f40da1c865e89a91b9f151c1e3346"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Char &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a926f40da1c865e89a91b9f151c1e3346">operator&lt;&lt;</a> (std::basic_ostream&lt; Char &gt; &amp;out, const <a class="el" href="structemsr_1_1Solution.html">emsr::Solution</a>&lt; Real &gt; &amp;sln)</td></tr>
<tr class="separator:a926f40da1c865e89a91b9f151c1e3346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138fa9753d495e1819e54d43d580720b"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Tp &gt; </td></tr>
<tr class="memitem:a138fa9753d495e1819e54d43d580720b"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a138fa9753d495e1819e54d43d580720b">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;os, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;poly)</td></tr>
<tr class="separator:a138fa9753d495e1819e54d43d580720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefffa447e50d21ac578b5c3aafc992e2"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Tp &gt; </td></tr>
<tr class="memitem:aefffa447e50d21ac578b5c3aafc992e2"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aefffa447e50d21ac578b5c3aafc992e2">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;os, const <a class="el" href="classemsr_1_1RationalPolynomial.html">RationalPolynomial</a>&lt; Tp &gt; &amp;poly)</td></tr>
<tr class="separator:aefffa447e50d21ac578b5c3aafc992e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729181f523e75cde6b49162acf500eb7"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:a729181f523e75cde6b49162acf500eb7"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a729181f523e75cde6b49162acf500eb7">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;os, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;poly)</td></tr>
<tr class="separator:a729181f523e75cde6b49162acf500eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f94cfb4f6d90681c4f279752b486a7"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:ab9f94cfb4f6d90681c4f279752b486a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ab9f94cfb4f6d90681c4f279752b486a7">operator==</a> (const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pa, const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pb)</td></tr>
<tr class="separator:ab9f94cfb4f6d90681c4f279752b486a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347cae7848e69cee8176eac10e5b9318"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a347cae7848e69cee8176eac10e5b9318"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a347cae7848e69cee8176eac10e5b9318">operator==</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a347cae7848e69cee8176eac10e5b9318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8196fd2e8625f2b62cee678b1022a90a"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a8196fd2e8625f2b62cee678b1022a90a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a8196fd2e8625f2b62cee678b1022a90a">operator==</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, const std::complex&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a8196fd2e8625f2b62cee678b1022a90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7319379b40a854772a1d399db164c920"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a7319379b40a854772a1d399db164c920"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a7319379b40a854772a1d399db164c920">operator==</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x, Real y)</td></tr>
<tr class="separator:a7319379b40a854772a1d399db164c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f6814c1b9e0c05405223c667442a85"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t Size&gt; </td></tr>
<tr class="memitem:a92f6814c1b9e0c05405223c667442a85"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a92f6814c1b9e0c05405223c667442a85">operator==</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;pa, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;pb)</td></tr>
<tr class="separator:a92f6814c1b9e0c05405223c667442a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7358b909c9c8bab8309daf7357c4ac5"><td class="memTemplParams" colspan="2">template&lt;typename Tp , std::size_t SizeA, std::size_t SizeB&gt; </td></tr>
<tr class="memitem:aa7358b909c9c8bab8309daf7357c4ac5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aa7358b909c9c8bab8309daf7357c4ac5">operator==</a> (const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeA &gt; &amp;, const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeB &gt; &amp;)</td></tr>
<tr class="separator:aa7358b909c9c8bab8309daf7357c4ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392d7f9e0468d80cd6b8067a133d139e"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a392d7f9e0468d80cd6b8067a133d139e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a392d7f9e0468d80cd6b8067a133d139e">operator==</a> (const std::complex&lt; Real &gt; &amp;x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a392d7f9e0468d80cd6b8067a133d139e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5d604182a149e63b319c13f72ccad3"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a6e5d604182a149e63b319c13f72ccad3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a6e5d604182a149e63b319c13f72ccad3">operator==</a> (Real x, const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;y)</td></tr>
<tr class="separator:a6e5d604182a149e63b319c13f72ccad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93634c3102d6a9a883994cbd19c9cff1"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Tp &gt; </td></tr>
<tr class="memitem:a93634c3102d6a9a883994cbd19c9cff1"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a93634c3102d6a9a883994cbd19c9cff1">operator&gt;&gt;</a> (std::basic_istream&lt; CharT, Traits &gt; &amp;is, <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;poly)</td></tr>
<tr class="separator:a93634c3102d6a9a883994cbd19c9cff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa608fda96ca8649cbdb86338e69846"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Tp &gt; </td></tr>
<tr class="memitem:a0fa608fda96ca8649cbdb86338e69846"><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a0fa608fda96ca8649cbdb86338e69846">operator&gt;&gt;</a> (std::basic_istream&lt; CharT, Traits &gt; &amp;is, <a class="el" href="classemsr_1_1RationalPolynomial.html">RationalPolynomial</a>&lt; Tp &gt; &amp;poly)</td></tr>
<tr class="separator:a0fa608fda96ca8649cbdb86338e69846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1354c9f828ac3f5761e03435aabf136"><td class="memTemplParams" colspan="2">template&lt;typename Real , typename _Iter &gt; </td></tr>
<tr class="memitem:ab1354c9f828ac3f5761e03435aabf136"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ab1354c9f828ac3f5761e03435aabf136">quadratic</a> (const _Iter &amp;_CC)</td></tr>
<tr class="memdesc:ab1354c9f828ac3f5761e03435aabf136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the roots of a quadratic equation of the form:  <a href="namespaceemsr.html#ab1354c9f828ac3f5761e03435aabf136">More...</a><br /></td></tr>
<tr class="separator:ab1354c9f828ac3f5761e03435aabf136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b524d40ae2c1c9a280df4408c8fed2"><td class="memTemplParams" colspan="2">template&lt;typename Real , typename Iter &gt; </td></tr>
<tr class="memitem:a00b524d40ae2c1c9a280df4408c8fed2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a00b524d40ae2c1c9a280df4408c8fed2">quadratic</a> (const Iter &amp;coef)</td></tr>
<tr class="separator:a00b524d40ae2c1c9a280df4408c8fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da681638d9a291cfbc004aac518e8ee"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2da681638d9a291cfbc004aac518e8ee"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a2da681638d9a291cfbc004aac518e8ee">quadratic</a> (Real c0, Real c1, Real c2)</td></tr>
<tr class="separator:a2da681638d9a291cfbc004aac518e8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822edeea9a631fdca6bd4634d67ee02e"><td class="memTemplParams" colspan="2">template&lt;typename Real , typename Iter &gt; </td></tr>
<tr class="memitem:a822edeea9a631fdca6bd4634d67ee02e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a822edeea9a631fdca6bd4634d67ee02e">quartic</a> (const Iter &amp;CC)</td></tr>
<tr class="memdesc:a822edeea9a631fdca6bd4634d67ee02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the roots a quartic equation of the form:  <a href="namespaceemsr.html#a822edeea9a631fdca6bd4634d67ee02e">More...</a><br /></td></tr>
<tr class="separator:a822edeea9a631fdca6bd4634d67ee02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa267aed0e5f2d4e6b290d99dad0bb87f"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aa267aed0e5f2d4e6b290d99dad0bb87f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aa267aed0e5f2d4e6b290d99dad0bb87f">quartic</a> (Real c0, Real c1, Real c2, Real c3, Real c4)</td></tr>
<tr class="separator:aa267aed0e5f2d4e6b290d99dad0bb87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328968ec7874ae8890a1d673aa9b1410"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#a3ddbab71ecfa506ad878ac9e60153a02">quot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a328968ec7874ae8890a1d673aa9b1410">quot</a> (int numer, int denom)</td></tr>
<tr class="separator:a328968ec7874ae8890a1d673aa9b1410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcdfe8ff564fe89c342ca83fbe5477c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#a858cd87acb34606af0ecef15aaae7db9">lquot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a4bcdfe8ff564fe89c342ca83fbe5477c">quot</a> (long int numer, long int denom)</td></tr>
<tr class="separator:a4bcdfe8ff564fe89c342ca83fbe5477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0e06e608d1d96388610dc17e52c43f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#a7c6dbac674a6a512a5cbd904d8e6ba10">llquot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#acc0e06e608d1d96388610dc17e52c43f">quot</a> (long long int numer, long long int denom)</td></tr>
<tr class="separator:acc0e06e608d1d96388610dc17e52c43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac087677b513a944eb60e5df77309a8df"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#a8e7689491743dc22cc5ad3ed13245199">squot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#ac087677b513a944eb60e5df77309a8df">quot</a> (short int numer, short int denom)</td></tr>
<tr class="separator:ac087677b513a944eb60e5df77309a8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864f68f8b3af8302e1ef49e2e7c7cda6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#ab11381c9f569c2c3d6ea24d63fbca345">intmaxquot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a864f68f8b3af8302e1ef49e2e7c7cda6">quot</a> (std::intmax_t x, std::intmax_t y)</td></tr>
<tr class="separator:a864f68f8b3af8302e1ef49e2e7c7cda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b69f1c91fb3480e098db4e4bfe949f2"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a3b69f1c91fb3480e098db4e4bfe949f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a3b69f1c91fb3480e098db4e4bfe949f2">real</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x)</td></tr>
<tr class="separator:a3b69f1c91fb3480e098db4e4bfe949f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac71b8e58e2db0192f8d87514170f8c3"><td class="memTemplParams" colspan="2">template&lt;std::size_t _Dim, typename _Iter , typename _NumTp &gt; </td></tr>
<tr class="memitem:aac71b8e58e2db0192f8d87514170f8c3"><td class="memTemplItemLeft" align="right" valign="top">_NumTp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aac71b8e58e2db0192f8d87514170f8c3">refine_solution_halley</a> (_NumTp z, const _Iter &amp;_CC)</td></tr>
<tr class="separator:aac71b8e58e2db0192f8d87514170f8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39848f35781685f7348bd000d4c8f04"><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim, typename Iter , typename NumTp &gt; </td></tr>
<tr class="memitem:aa39848f35781685f7348bd000d4c8f04"><td class="memTemplItemLeft" align="right" valign="top">NumTp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aa39848f35781685f7348bd000d4c8f04">refine_solution_halley</a> (NumTp z, const Iter &amp;CC)</td></tr>
<tr class="separator:aa39848f35781685f7348bd000d4c8f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771083ec16ae63a6c0a545c7bef25d9a"><td class="memTemplParams" colspan="2">template&lt;std::size_t _Dim, typename _Iter , typename _NumTp &gt; </td></tr>
<tr class="memitem:a771083ec16ae63a6c0a545c7bef25d9a"><td class="memTemplItemLeft" align="right" valign="top">_NumTp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a771083ec16ae63a6c0a545c7bef25d9a">refine_solution_newton</a> (_NumTp z, const _Iter &amp;_CC)</td></tr>
<tr class="separator:a771083ec16ae63a6c0a545c7bef25d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c391643349e3d33d22c04af7e639e59"><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim, typename Iter , typename NumTp &gt; </td></tr>
<tr class="memitem:a0c391643349e3d33d22c04af7e639e59"><td class="memTemplItemLeft" align="right" valign="top">NumTp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a0c391643349e3d33d22c04af7e639e59">refine_solution_newton</a> (NumTp z, const Iter &amp;CC)</td></tr>
<tr class="separator:a0c391643349e3d33d22c04af7e639e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb77296ece59944a997721abe25c58a"><td class="memTemplParams" colspan="2">template&lt;std::size_t _Dim, typename _Iter , typename Real &gt; </td></tr>
<tr class="memitem:abbb77296ece59944a997721abe25c58a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#abbb77296ece59944a997721abe25c58a">refine_solutions</a> (std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, _Dim - 1 &gt; &amp;_ZZ, const _Iter &amp;_CC)</td></tr>
<tr class="separator:abbb77296ece59944a997721abe25c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af587fd280f06e9ece8a65d17b94951fb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#af587fd280f06e9ece8a65d17b94951fb">remquo</a> (double x, double y)</td></tr>
<tr class="separator:af587fd280f06e9ece8a65d17b94951fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff207b997391cf05f4fe14aa23d5302"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#afff207b997391cf05f4fe14aa23d5302">remquo</a> (float x, float y)</td></tr>
<tr class="separator:afff207b997391cf05f4fe14aa23d5302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf92d848c3dc6a420b3bc5052fd0e5f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a9cf92d848c3dc6a420b3bc5052fd0e5f">remquo</a> (long double x, long double y)</td></tr>
<tr class="separator:a9cf92d848c3dc6a420b3bc5052fd0e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c31c647ef9dd9dd717fe042d207fad"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a67c31c647ef9dd9dd717fe042d207fad">remquof</a> (float x, float y)</td></tr>
<tr class="separator:a67c31c647ef9dd9dd717fe042d207fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3f01d2d56357ae6e6b9425534e8316"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a0b3f01d2d56357ae6e6b9425534e8316">remquol</a> (long double x, long double y)</td></tr>
<tr class="separator:a0b3f01d2d56357ae6e6b9425534e8316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f461846493fb75c010254d3486e6d5"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a61f461846493fb75c010254d3486e6d5"><td class="memTemplItemLeft" align="right" valign="top">Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a61f461846493fb75c010254d3486e6d5">sign</a> (Tp x)</td></tr>
<tr class="separator:a61f461846493fb75c010254d3486e6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefee9f0dea81a2a28f122bd1c8535fbd"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:aefee9f0dea81a2a28f122bd1c8535fbd"><td class="memTemplItemLeft" align="right" valign="top">Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#aefee9f0dea81a2a28f122bd1c8535fbd">signum</a> (Tp x)</td></tr>
<tr class="separator:aefee9f0dea81a2a28f122bd1c8535fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8191598409fa9366baf28c5aa39928d3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemsr.html#a8e7689491743dc22cc5ad3ed13245199">squot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a8191598409fa9366baf28c5aa39928d3">squot</a> (short int numer, short int denom)</td></tr>
<tr class="separator:a8191598409fa9366baf28c5aa39928d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4e7f7636909dc8a88bc53d81f43eaf"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a8b4e7f7636909dc8a88bc53d81f43eaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a8b4e7f7636909dc8a88bc53d81f43eaf">swap</a> (<a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pa, <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;pb) noexcept(noexcept(pa.swap(pb)))</td></tr>
<tr class="separator:a8b4e7f7636909dc8a88bc53d81f43eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fe15f97bf442f3b709d901904a5c72"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a31fe15f97bf442f3b709d901904a5c72"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a31fe15f97bf442f3b709d901904a5c72">to_complex</a> (const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;x)</td></tr>
<tr class="separator:a31fe15f97bf442f3b709d901904a5c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5bf2c62dcc64e44b8b65766f71d8aa64"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a5bf2c62dcc64e44b8b65766f71d8aa64"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a5bf2c62dcc64e44b8b65766f71d8aa64">has_imag_v</a> = <a class="el" href="structemsr_1_1has__imag__t.html">has_imag_t</a>&lt;Tp&gt;::value</td></tr>
<tr class="separator:a5bf2c62dcc64e44b8b65766f71d8aa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e13ee841ec1f2dbfb09ed021036d3a"><td class="memTemplParams" colspan="2">template&lt;typename Tp &gt; </td></tr>
<tr class="memitem:a59e13ee841ec1f2dbfb09ed021036d3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemsr.html#a59e13ee841ec1f2dbfb09ed021036d3a">has_value_type_v</a> = <a class="el" href="structemsr_1_1has__value__type__t.html">has_value_type_t</a>&lt;Tp&gt;::value</td></tr>
<tr class="separator:a59e13ee841ec1f2dbfb09ed021036d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a dense univariate polynomial.</p>
<p>This polynomial has a size of at least one - degree 0. The zero polynomial has a_0 = 0. There is no null polynomial. size == degree + 1</p>
<p>How to handle division? operator/ returns the quotient of two polynomials discarding the remainder. operator% returns the remainder of two polynomials discarding the quotient. The divmod functions computes both the quotient and the remainder. N. B. I could add the remquo function?</p><ul>
<li>Largest coefficient: This class does not enforce the coefficient of largest power to be nonzero. The user concerned about this should use the deflate method with a tolerance for the minimim magnitude coefficient. This library provides another deflate method that divides out a polynomial that is expected to factor the polynomial within a tolerance on the minimim magnitude coefficient. If the remainder is non-zero then an exception is thrown.</li>
</ul>
<p>Mixed-type evaluation: It is common to have integer coefficient polynomials that you wish to evaluate at floating opint or complex values, or real-valued coefficient polynomials evaluate at complex values. For this reason we need evaluation function templates in this library.</p>
<p>It would be promote_t&lt;complex::value_type&gt; for complex. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab11381c9f569c2c3d6ea24d63fbca345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11381c9f569c2c3d6ea24d63fbca345">&#9670;&nbsp;</a></span>intmaxquot_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemsr.html#ab11381c9f569c2c3d6ea24d63fbca345">emsr::intmaxquot_t</a> = typedef <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt;std::intmax_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00082">82</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>

</div>
</div>
<a id="a7c6dbac674a6a512a5cbd904d8e6ba10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6dbac674a6a512a5cbd904d8e6ba10">&#9670;&nbsp;</a></span>llquot_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemsr.html#a7c6dbac674a6a512a5cbd904d8e6ba10">emsr::llquot_t</a> = typedef <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt;long long int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00081">81</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>

</div>
</div>
<a id="a858cd87acb34606af0ecef15aaae7db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858cd87acb34606af0ecef15aaae7db9">&#9670;&nbsp;</a></span>lquot_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemsr.html#a858cd87acb34606af0ecef15aaae7db9">emsr::lquot_t</a> = typedef <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt;long int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00080">80</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>

</div>
</div>
<a id="a3ddbab71ecfa506ad878ac9e60153a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddbab71ecfa506ad878ac9e60153a02">&#9670;&nbsp;</a></span>quot_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemsr.html#a3ddbab71ecfa506ad878ac9e60153a02">emsr::quot_t</a> = typedef <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00079">79</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>

</div>
</div>
<a id="a02ec0ebded7be3a1b57643770c87e413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ec0ebded7be3a1b57643770c87e413">&#9670;&nbsp;</a></span>real_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemsr.html#a02ec0ebded7be3a1b57643770c87e413">emsr::real_type_t</a> = typedef typename <a class="el" href="structemsr_1_1real__type.html">real_type</a>&lt;Tp&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00125">125</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>

</div>
</div>
<a id="a8e7689491743dc22cc5ad3ed13245199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7689491743dc22cc5ad3ed13245199">&#9670;&nbsp;</a></span>squot_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemsr.html#a8e7689491743dc22cc5ad3ed13245199">emsr::squot_t</a> = typedef <a class="el" href="structemsr_1_1int__quot__t.html">int_quot_t</a>&lt;short int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00078">78</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a782d36096e8467b4a45a9dc2f89355b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782d36096e8467b4a45a9dc2f89355b2">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Real emsr::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00097">97</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keywordflow">return</span> std::numeric_limits&lt;Real&gt;::quiet_NaN();</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">std::abs</a>(std::get&lt;1&gt;(x));</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">std::abs</a>(std::get&lt;2&gt;(x));</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div>
<div class="ttc" id="anamespaceemsr_html_a782d36096e8467b4a45a9dc2f89355b2"><div class="ttname"><a href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">emsr::abs</a></div><div class="ttdeci">constexpr Real abs(const Solution&lt; Real &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="solution_8h_source.html#l00097">solution.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="affe4f64b8e546b29054514e013560ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe4f64b8e546b29054514e013560ea0">&#9670;&nbsp;</a></span>cubic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real , typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 3 &gt; emsr::cubic </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>CC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the roots of a cubic equation of the form: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_3 x^3 + a_2 x^2 + a_1 x + a_0 = 0 \]" src="form_10.png" width="150" height="15"/>
</p>
<p> for real coefficients <img class="formulaInl" alt="$ a_k $" src="form_7.png" width="11" height="9"/>.</p>
<p>In the non-degenerate case there are three roots:</p><ul>
<li>All three roots are real</li>
<li>One root is real and the other two are a complex conjugate pair</li>
</ul>
<p>If the cubic coefficient <img class="formulaInl" alt="$ a_3 $" src="form_11.png" width="11" height="9"/> is zero (degenerate case) the problem is referred to the quadratic solver to return, at most, two valid roots.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_CC</td><td>Array that contains the four coefficients of the cubic equation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="solver__low__degree_8tcc_source.html#l00216">216</a> of file <a class="el" href="solver__low__degree_8tcc_source.html">solver_low_degree.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      std::array&lt;Solution&lt;Real&gt;, 3&gt; ZZ;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160; </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      <span class="keywordflow">if</span> (CC[3] == Real{0})</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;          <span class="comment">// Last root is null, remaining equation is quadratic.</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> ZZ2 = quadratic&lt;Real&gt;(CC);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;          ZZ[0] = ZZ2[0];</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;          ZZ[1] = ZZ2[1];</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CC[0] == Real{0})</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;          <span class="comment">// First root is zero, remaining equation is quadratic.</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;          ZZ[0] = Real{0};</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> ZZ2 = quadratic&lt;Real&gt;(CC[1], CC[2], CC[3]);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;          ZZ[1] = ZZ2[0];</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;          ZZ[2] = ZZ2[1];</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        }</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        {</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;          <span class="comment">// Normalize cubic equation coefficients.</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;          std::array&lt;Real, 4&gt; AA3;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;          AA3[3] = Real{1};</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;          AA3[2] = CC[2] / CC[3];</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;          AA3[1] = CC[1] / CC[3];</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;          AA3[0] = CC[0] / CC[3];</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160; </div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> S_2pi</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            = 2 * Real{3.1415&#39;92653&#39;58979&#39;32384&#39;62643&#39;38327&#39;95028&#39;84195e+0L};</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> PP = AA3[2] / Real{3};</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> QQ = (AA3[2] * AA3[2] - Real{3} * AA3[1])</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                         / Real{9};</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> QQp3 = QQ * QQ * QQ;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> RR = (Real{2} * AA3[2] * AA3[2] * AA3[2]</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                          - Real{9} * AA3[2] * AA3[1]</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                          + Real{27} * AA3[0]) / Real{54};</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> RRp2 = RR * RR;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160; </div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;          <span class="keywordflow">if</span> (QQp3 - RRp2 &gt; Real{0})</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            {</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;              <span class="comment">// Calculate the three real roots.</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;              <span class="keyword">const</span> <span class="keyword">auto</span> phi = std::acos(RR / std::sqrt(QQp3));</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;              <span class="keyword">const</span> <span class="keyword">auto</span> fact = -Real{2} * std::sqrt(QQ);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                ZZ[i] = fact * std::cos((phi + i * S_2pi) / Real{3}) - PP;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            }</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            {</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;              <span class="comment">// Calculate the single real root.</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;              <span class="keyword">const</span> <span class="keyword">auto</span> fact = std::cbrt(<a class="code" href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">std::abs</a>(RR)</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                                          + std::sqrt(RRp2 - QQp3));</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;              <span class="keyword">const</span> <span class="keyword">auto</span> BB = -std::copysign(fact + QQ / fact, RR);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;              ZZ[0] = BB - PP;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160; </div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;              <span class="comment">// Find the other two roots which are complex conjugates.</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;              std::array&lt;Real, 3&gt; AA2;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;              AA2[2] = Real{1};</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;              AA2[1] = BB;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;              AA2[0] = BB * BB - Real{3} * QQ;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;              <span class="keyword">const</span> <span class="keyword">auto</span> ZZ2 = quadratic&lt;Real&gt;(AA2);</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;              ZZ[1] = std::get&lt;2&gt;(ZZ2[0]) - PP;</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;              ZZ[2] = std::get&lt;2&gt;(ZZ2[1]) - PP;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            }</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        }</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160; </div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;      <span class="keywordflow">return</span> ZZ;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad78d9f421df742cad9c10eb3c753f7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78d9f421df742cad9c10eb3c753f7b8">&#9670;&nbsp;</a></span>cubic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt;, 3&gt; emsr::cubic </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solver__low__degree_8h_source.html#l00073">73</a> of file <a class="el" href="solver__low__degree_8h_source.html">solver_low_degree.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;      <span class="keywordflow">return</span> cubic&lt;Real&gt;(std::array&lt;Real, 4&gt;{c0, c1, c2, c3});</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d92c91e21caca3557589683df6650c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d92c91e21caca3557589683df6650c4">&#9670;&nbsp;</a></span>divmod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emsr::divmod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>den</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>quo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>rem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide two polynomials returning the quotient and remainder. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8tcc_source.html#l00385">385</a> of file <a class="el" href="polynomial_8tcc_source.html">polynomial.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;      rem = num;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;      quo = Polynomial&lt;Tp&gt;(Tp{}, num.degree());</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      <span class="keyword">const</span> std::size_t d_num = num.degree();</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;      <span class="keyword">const</span> std::size_t d_den = den.degree();</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;      <span class="keywordflow">if</span> (d_den &lt;= d_num)</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        {</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = d_num - d_den; k &gt;= 0; --k)</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;            {</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;              quo.coefficient(k, rem.coefficient(d_den + k)</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                                   / den.coefficient(d_den));</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = d_den + k - 1; j &gt;= k; --j)</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                rem.coefficient(j, rem.coefficient(j)</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                                     - quo.coefficient(k)</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                                     * den.coefficient(j - k));</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;            }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;          quo.degree(d_num - d_den);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;          rem.degree(d_den &gt; 0 ? d_den - 1 : 0);</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        }</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        quo.degree(0);</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acef21b65838fd0c04b66d44127996289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef21b65838fd0c04b66d44127996289">&#9670;&nbsp;</a></span>divmod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t SizeN, std::size_t SizeD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1divmod__t.html">divmod_t</a>&lt; Tp, SizeN, SizeD &gt; emsr::divmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeN &gt;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeD &gt;&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide two polynomials returning the quotient and remainder. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8tcc_source.html#l00065">65</a> of file <a class="el" href="static__polynomial_8tcc_source.html">static_polynomial.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      constexpr <span class="keyword">auto</span> DegN = num.degree();</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      constexpr <span class="keyword">auto</span> DegD = den.degree();</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      <span class="keyword">auto</span> rem = num;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;      <span class="keyword">auto</span> quo = StaticPolynomial&lt;Tp, SizeN&gt;{};</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;      <span class="keywordflow">if</span> (DegD &lt;= DegN)</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        {</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;          <span class="keywordflow">for</span> (std::ptrdiff_t k = DegN - DegD; k &gt;= 0; --k)</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;              quo.coefficient(k, rem.coefficient(DegD + k)</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                                   / den.coefficient(DegD));</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = DegD + k - 1; j &gt;= k; --j)</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                rem.coefficient(j, rem.coefficient(j)</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                                       - quo.coefficient(k)</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                                       * den.coefficient(j - k));</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            }</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        }</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;      divmod_t&lt;Tp, SizeN, SizeD&gt; ret;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0ULL; i &lt; divmod_t&lt;Tp, SizeN, SizeD&gt;::SizeQuo; ++i)</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        ret.quo[i] = quo[i];</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      for (std::size_t i = 0ULL; i &lt; divmod_t&lt;Tp, SizeN, SizeD&gt;::SizeRem; ++i)</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        ret.rem[i] = rem[i];</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abb382de8e6aff992729a230f89525101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb382de8e6aff992729a230f89525101">&#9670;&nbsp;</a></span>exp10f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float emsr::exp10f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a624fb5e5eea1d39f8d701c1d62cce358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624fb5e5eea1d39f8d701c1d62cce358">&#9670;&nbsp;</a></span>exp10log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double emsr::exp10log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46a7f2674537e3b49666a7ded50d1db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a7f2674537e3b49666a7ded50d1db8">&#9670;&nbsp;</a></span>exp10logl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double emsr::exp10logl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fc0119932c1b3a45cba25185cb951a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc0119932c1b3a45cba25185cb951a7">&#9670;&nbsp;</a></span>expm1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;Tp&gt; emsr::expm1 </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Give complex expm1. This and log1p are inverses of each other. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Do a better complex log1p implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00513">513</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">      /// @todo Do a better complex log1p implementation.</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment"></span>      <span class="keywordflow">return</span> std::exp(z) - Tp{1};</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2bc8058fc99599e5fcdd1b70250c84ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc8058fc99599e5fcdd1b70250c84ac">&#9670;&nbsp;</a></span>expm1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp emsr::expm1 </td>
          <td>(</td>
          <td class="paramtype">Tp&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normal log1p (in this namespace). </p>

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00502">502</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    {</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a3fc0119932c1b3a45cba25185cb951a7">std::expm1</a>(x);</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    }</div>
<div class="ttc" id="anamespaceemsr_html_a3fc0119932c1b3a45cba25185cb951a7"><div class="ttname"><a href="namespaceemsr.html#a3fc0119932c1b3a45cba25185cb951a7">emsr::expm1</a></div><div class="ttdeci">std::complex&lt; Tp &gt; expm1(const std::complex&lt; Tp &gt; &amp;z)</div><div class="ttdef"><b>Definition:</b> <a href="notsospecfun_8h_source.html#l00513">notsospecfun.h:513</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a733f95a5b7d092ab0423af88d1bb6768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733f95a5b7d092ab0423af88d1bb6768">&#9670;&nbsp;</a></span>fma() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;Tp&gt; emsr::fma </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Give complex an fma. </p>

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00465">465</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    {</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> [ar, ai] = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>Tp(&amp;)[2]<span class="keyword">&gt;</span>(a);</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> [zr, zi] = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>Tp(&amp;)[2]<span class="keyword">&gt;</span>(z);</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> [br, bi] = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>Tp(&amp;)[2]<span class="keyword">&gt;</span>(b);</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> wr = <a class="code" href="namespaceemsr.html#a733f95a5b7d092ab0423af88d1bb6768">std::fma</a>(ar, ai, -<a class="code" href="namespaceemsr.html#a733f95a5b7d092ab0423af88d1bb6768">std::fma</a>(ai, zi, -br));</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> wi = <a class="code" href="namespaceemsr.html#a733f95a5b7d092ab0423af88d1bb6768">std::fma</a>(ar, zi, <a class="code" href="namespaceemsr.html#a733f95a5b7d092ab0423af88d1bb6768">std::fma</a>(ai, zr, bi));</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;      <span class="keywordflow">return</span> {wr, wi};</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    }</div>
<div class="ttc" id="anamespaceemsr_html_a733f95a5b7d092ab0423af88d1bb6768"><div class="ttname"><a href="namespaceemsr.html#a733f95a5b7d092ab0423af88d1bb6768">emsr::fma</a></div><div class="ttdeci">std::complex&lt; Tp &gt; fma(const std::complex&lt; Tp &gt; &amp;a, const std::complex&lt; Tp &gt; &amp;z, const std::complex&lt; Tp &gt; &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="notsospecfun_8h_source.html#l00465">notsospecfun.h:465</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9d471bddd0d8162bc3bed84f4930312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d471bddd0d8162bc3bed84f4930312">&#9670;&nbsp;</a></span>fma() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp emsr::fma </td>
          <td>(</td>
          <td class="paramtype">Tp&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tp&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tp&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normal fma (in this namespace). </p>

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00455">455</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    {</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a733f95a5b7d092ab0423af88d1bb6768">std::fma</a>(a, b, c);</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adcd7b690135a53730e52d903bd2b87f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd7b690135a53730e52d903bd2b87f5">&#9670;&nbsp;</a></span>frexp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt;double&gt; emsr::frexp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebac42aafb021bf490f4cd15be2e2c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebac42aafb021bf490f4cd15be2e2c47">&#9670;&nbsp;</a></span>frexp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt;float&gt; emsr::frexp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d24b7cd96bd605e04fdeaff84e5561d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d24b7cd96bd605e04fdeaff84e5561d">&#9670;&nbsp;</a></span>frexp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt;long double&gt; emsr::frexp </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73997c8089c4b9fc4225bb2b91e80d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73997c8089c4b9fc4225bb2b91e80d93">&#9670;&nbsp;</a></span>frexpf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt;float&gt; emsr::frexpf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af25ac2cbc0c43972d690d3e5375363bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25ac2cbc0c43972d690d3e5375363bf">&#9670;&nbsp;</a></span>frexpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1frexp__t.html">frexp_t</a>&lt;long double&gt; emsr::frexpl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9fe740b04b1f58f0cafe9042b5a380b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fe740b04b1f58f0cafe9042b5a380b">&#9670;&nbsp;</a></span>get_scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceemsr.html#a02ec0ebded7be3a1b57643770c87e413">real_type_t</a>&lt;<a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;Tp&gt; &gt; emsr::get_scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the scale for a polynomial. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00889">889</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    { <span class="keywordflow">return</span> poly.m_get_scale(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af8bdedf1c9d27acc3695f86d226ca149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bdedf1c9d27acc3695f86d226ca149">&#9670;&nbsp;</a></span>get_scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(std::abs(Tp())) emsr::get_scale </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the scale for a number. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00897">897</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">std::abs</a>(x); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad76e856347b8d4dc1991d8aad92199f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76e856347b8d4dc1991d8aad92199f0">&#9670;&nbsp;</a></span>horner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT , typename Coef0 , typename... Coef&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value, double, ArgT&gt; emsr::horner </td>
          <td>(</td>
          <td class="paramtype">ArgT&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coef0&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coef...&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform compile-time evaluation of a constant polynomial. The polynomial coefficients are lowest-order first. </p>

<p class="definition">Definition at line <a class="el" href="horner_8h_source.html#l00055">55</a> of file <a class="el" href="horner_8h_source.html">horner.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keyword">using</span> arg_t = std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value,</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                     double, ArgT&gt;;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">return</span> arg_t(c0) + x * <a class="code" href="namespaceemsr.html#ad76e856347b8d4dc1991d8aad92199f0">horner</a>(x, c...);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  }</div>
<div class="ttc" id="anamespaceemsr_html_ad76e856347b8d4dc1991d8aad92199f0"><div class="ttname"><a href="namespaceemsr.html#ad76e856347b8d4dc1991d8aad92199f0">emsr::horner</a></div><div class="ttdeci">constexpr std::conditional_t&lt; std::is_integral&lt; ArgT &gt;::value, double, ArgT &gt; horner(ArgT x, Coef0 c0, Coef... c)</div><div class="ttdef"><b>Definition:</b> <a href="horner_8h_source.html#l00055">horner.h:55</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a155d146e57554633b51b21e4681ce000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155d146e57554633b51b21e4681ce000">&#9670;&nbsp;</a></span>horner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT , typename Coef0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value, double, ArgT&gt; emsr::horner </td>
          <td>(</td>
          <td class="paramtype">ArgT&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coef0&#160;</td>
          <td class="paramname"><em>c0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform compile-time evaluation of a constant zero-order polynomial. </p>

<p class="definition">Definition at line <a class="el" href="horner_8h_source.html#l00042">42</a> of file <a class="el" href="horner_8h_source.html">horner.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keyword">using</span> arg_t = std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value,</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                                     double, ArgT&gt;;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordflow">return</span> arg_t(c0);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a381a03247643fc05de000c9d2ccbbe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381a03247643fc05de000c9d2ccbbe12">&#9670;&nbsp;</a></span>horner_big_end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT , typename Coef1 , typename Coef0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value, double, ArgT&gt; emsr::horner_big_end </td>
          <td>(</td>
          <td class="paramtype">ArgT&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coef1&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coef0&#160;</td>
          <td class="paramname"><em>c0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform compile-time evaluation of a constant first-order polynomial. The polynomial coefficients are highest-order first. </p>

<p class="definition">Definition at line <a class="el" href="horner_8h_source.html#l00082">82</a> of file <a class="el" href="horner_8h_source.html">horner.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keyword">using</span> arg_t = std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value,</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                                     double, ArgT&gt;;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#acc246a38d5dc59a528e6fc7ec3d38b5a">horner_big_end</a>(x, x * arg_t(c1) + arg_t(c0));</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  }</div>
<div class="ttc" id="anamespaceemsr_html_acc246a38d5dc59a528e6fc7ec3d38b5a"><div class="ttname"><a href="namespaceemsr.html#acc246a38d5dc59a528e6fc7ec3d38b5a">emsr::horner_big_end</a></div><div class="ttdeci">constexpr std::conditional_t&lt; std::is_integral&lt; ArgT &gt;::value, double, ArgT &gt; horner_big_end(ArgT x, CoefN cn, CoefNm1 cnm1, Coef... c)</div><div class="ttdef"><b>Definition:</b> <a href="horner_8h_source.html#l00095">horner.h:95</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acc246a38d5dc59a528e6fc7ec3d38b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc246a38d5dc59a528e6fc7ec3d38b5a">&#9670;&nbsp;</a></span>horner_big_end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT , typename CoefN , typename CoefNm1 , typename... Coef&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value, double, ArgT&gt; emsr::horner_big_end </td>
          <td>(</td>
          <td class="paramtype">ArgT&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoefN&#160;</td>
          <td class="paramname"><em>cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoefNm1&#160;</td>
          <td class="paramname"><em>cnm1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coef...&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform compile-time evaluation of a constant polynomial. The polynomial coefficients are highest-order first. </p>

<p class="definition">Definition at line <a class="el" href="horner_8h_source.html#l00095">95</a> of file <a class="el" href="horner_8h_source.html">horner.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keyword">using</span> arg_t = std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value,</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                                     double, ArgT&gt;;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#acc246a38d5dc59a528e6fc7ec3d38b5a">horner_big_end</a>(x, x * arg_t(cn) + arg_t(cnm1), c...);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a55de120e4dc9c5c34075279bdf43d17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55de120e4dc9c5c34075279bdf43d17c">&#9670;&nbsp;</a></span>horner_big_end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT , typename Coef0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value, double, ArgT&gt; emsr::horner_big_end </td>
          <td>(</td>
          <td class="paramtype">ArgT&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coef0&#160;</td>
          <td class="paramname"><em>c0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform compile-time evaluation of a constant zero-order polynomial. The polynomial coefficients are highest-order first. </p>

<p class="definition">Definition at line <a class="el" href="horner_8h_source.html#l00069">69</a> of file <a class="el" href="horner_8h_source.html">horner.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="keyword">using</span> arg_t = std::conditional_t&lt;std::is_integral&lt;ArgT&gt;::value,</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                     double, ArgT&gt;;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keywordflow">return</span> arg_t(c0);</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a79ddc0cda81a11ab065e5caae9e0907a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ddc0cda81a11ab065e5caae9e0907a">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Real emsr::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00085">85</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordflow">return</span> std::numeric_limits&lt;Real&gt;::quiet_NaN();</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">return</span> Real{0};</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a79ddc0cda81a11ab065e5caae9e0907a">std::imag</a>(std::get&lt;2&gt;(x));</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    }</div>
<div class="ttc" id="anamespaceemsr_html_a79ddc0cda81a11ab065e5caae9e0907a"><div class="ttname"><a href="namespaceemsr.html#a79ddc0cda81a11ab065e5caae9e0907a">emsr::imag</a></div><div class="ttdeci">constexpr Real imag(const Solution&lt; Real &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="solution_8h_source.html#l00085">solution.h:85</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af0802472e214876defe3080bce9fe631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0802472e214876defe3080bce9fe631">&#9670;&nbsp;</a></span>intmaxquot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#ab11381c9f569c2c3d6ea24d63fbca345">intmaxquot_t</a> emsr::intmaxquot </td>
          <td>(</td>
          <td class="paramtype">std::intmax_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::intmax_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad500d5a09de89975430355fd46c9be25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad500d5a09de89975430355fd46c9be25">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00068">68</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    { <span class="keywordflow">return</span> x.index() != 0; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a272468eace328b906a032e5273588040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272468eace328b906a032e5273588040">&#9670;&nbsp;</a></span>llquot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#a7c6dbac674a6a512a5cbd904d8e6ba10">llquot_t</a> emsr::llquot </td>
          <td>(</td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0ccee3147194cc2f4f937af47adddab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ccee3147194cc2f4f937af47adddab">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double emsr::log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14fd9693dd2a6a63599013938c3a76f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14fd9693dd2a6a63599013938c3a76f7">&#9670;&nbsp;</a></span>log1p() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;Tp&gt; emsr::log1p </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Give complex log1p. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Do a better complex log1p implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00491">491</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment">      /// @todo Do a better complex log1p implementation.</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment"></span>      <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#ad0ccee3147194cc2f4f937af47adddab">std::log</a>(Tp{1} + z);</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    }</div>
<div class="ttc" id="anamespaceemsr_html_ad0ccee3147194cc2f4f937af47adddab"><div class="ttname"><a href="namespaceemsr.html#ad0ccee3147194cc2f4f937af47adddab">emsr::log</a></div><div class="ttdeci">double log(double base, double x)</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a118130fce7fc0ef3f1231bf0c6a21259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118130fce7fc0ef3f1231bf0c6a21259">&#9670;&nbsp;</a></span>log1p() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp emsr::log1p </td>
          <td>(</td>
          <td class="paramtype">Tp&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normal log1p (in this namespace). </p>

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00481">481</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    {</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a14fd9693dd2a6a63599013938c3a76f7">std::log1p</a>(x);</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    }</div>
<div class="ttc" id="anamespaceemsr_html_a14fd9693dd2a6a63599013938c3a76f7"><div class="ttname"><a href="namespaceemsr.html#a14fd9693dd2a6a63599013938c3a76f7">emsr::log1p</a></div><div class="ttdeci">std::complex&lt; Tp &gt; log1p(const std::complex&lt; Tp &gt; &amp;z)</div><div class="ttdef"><b>Definition:</b> <a href="notsospecfun_8h_source.html#l00491">notsospecfun.h:491</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abc8ccf5fc5827ad75cc4a78e0af5170f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8ccf5fc5827ad75cc4a78e0af5170f">&#9670;&nbsp;</a></span>logf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float emsr::logf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00236804cfcde3d04cae74c577acc4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00236804cfcde3d04cae74c577acc4af">&#9670;&nbsp;</a></span>logl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double emsr::logl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23c24d6521dc8d94c2f7c0b7e1f01b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c24d6521dc8d94c2f7c0b7e1f01b38">&#9670;&nbsp;</a></span>lquot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#a858cd87acb34606af0ecef15aaae7db9">lquot_t</a> emsr::lquot </td>
          <td>(</td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b35da26edac14bb58a005527b989a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b35da26edac14bb58a005527b989a89">&#9670;&nbsp;</a></span>modf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt;double&gt; emsr::modf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad01b1428c15d190dfe08aa38279f0db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01b1428c15d190dfe08aa38279f0db0">&#9670;&nbsp;</a></span>modf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt;float&gt; emsr::modf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a464b7b372773df38dea93734e02be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a464b7b372773df38dea93734e02be8">&#9670;&nbsp;</a></span>modf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt;long double&gt; emsr::modf </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a377018ccb1391c355b93a196f0ad8abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377018ccb1391c355b93a196f0ad8abd">&#9670;&nbsp;</a></span>modff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt;float&gt; emsr::modff </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ed6e215d68b190d8d1bb41e74067f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed6e215d68b190d8d1bb41e74067f27">&#9670;&nbsp;</a></span>modfl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1modf__t.html">modf_t</a>&lt;long double&gt; emsr::modfl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af260f11b5410b8f8c2bfffd4e66ac74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af260f11b5410b8f8c2bfffd4e66ac74f">&#9670;&nbsp;</a></span>nan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double emsr::nan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a087f46f5fadc56390bf152e5b32c146b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087f46f5fadc56390bf152e5b32c146b">&#9670;&nbsp;</a></span>nanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emsr::nanf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7b28319a5e2e896cb29b98b60b9383f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b28319a5e2e896cb29b98b60b9383f">&#9670;&nbsp;</a></span>nanl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr long double emsr::nanl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16a330b4ef9bcc0f45e8fd412567322e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a330b4ef9bcc0f45e8fd412567322e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emsr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return false if two polynomials are equal. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l01060">1060</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;    { <span class="keywordflow">return</span> !(pa == pb); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad52e42498f67025febd9075ad75b0645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52e42498f67025febd9075ad75b0645">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00372">372</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    { <span class="keywordflow">return</span> !(x == y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a65037c6f423a051e29798d1039949525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65037c6f423a051e29798d1039949525">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00387">387</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    { <span class="keywordflow">return</span> !(x == y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7fc1800f8665163ddee970a134d64bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fc1800f8665163ddee970a134d64bb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emsr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00377">377</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    { <span class="keywordflow">return</span> !(x == y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a09d5ac2d244366ee3e69ae9b6f1e7b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d5ac2d244366ee3e69ae9b6f1e7b0c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return false if two polynomials are equal. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00653">653</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    { <span class="keywordflow">return</span> !(pa == pb); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a72376979bbd5b2bb27e73e4ea38bf5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72376979bbd5b2bb27e73e4ea38bf5c8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t SizeA, std::size_t SizeB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeA &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeB &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return false if two polynomials are equal. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00644">644</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7dbf4dea4cebcd849d6c9d6811289073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbf4dea4cebcd849d6c9d6811289073">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00392">392</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    { <span class="keywordflow">return</span> !(x == y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ca6592331d19bfa53c432a5ea9f442e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca6592331d19bfa53c432a5ea9f442e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator!= </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00382">382</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    { <span class="keywordflow">return</span> !(x == y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adbd25852afa794395ff3c829b2eb023b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd25852afa794395ff3c829b2eb023b">&#9670;&nbsp;</a></span>operator%() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() / Up())&gt; emsr::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the modulus or remainder of one polynomial relative to another one. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l01001">1001</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() / Up())&gt;(pa) %= pb; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed9775373361a9859b3504c2d9c6bfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9775373361a9859b3504c2d9c6bfbb">&#9670;&nbsp;</a></span>operator%() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() / Up())&gt; emsr::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Up &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00961">961</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() / Up())&gt;(poly) %= x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1b83fde2c334cc77b0a97884ce2ffcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b83fde2c334cc77b0a97884ce2ffcd">&#9670;&nbsp;</a></span>operator%() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() / Up())&gt; emsr::operator% </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the modulus or remainder of a scalar divided by a polynomial. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l01017">1017</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() / Up())&gt;(x) %= poly; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acf765562606a0b8a941a5cb24ecd1f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf765562606a0b8a941a5cb24ecd1f2e">&#9670;&nbsp;</a></span>operator%() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, <a class="el" href="structemsr_1_1divmod__t.html">divmod_t</a>&lt;Tp, SizeP, SizeQ&gt;::SizeRem&gt; emsr::operator% </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the remainder of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00803">803</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#acef21b65838fd0c04b66d44127996289">divmod</a>(P, Q).rem; }</div>
<div class="ttc" id="anamespaceemsr_html_acef21b65838fd0c04b66d44127996289"><div class="ttname"><a href="namespaceemsr.html#acef21b65838fd0c04b66d44127996289">emsr::divmod</a></div><div class="ttdeci">constexpr divmod_t&lt; Tp, SizeN, SizeD &gt; divmod(StaticPolynomial&lt; Tp, SizeN &gt; num, StaticPolynomial&lt; Tp, SizeD &gt; den)</div><div class="ttdef"><b>Definition:</b> <a href="static__polynomial_8tcc_source.html#l00065">static_polynomial.tcc:65</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8744ef4ccdde86f46197a7da33e0053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8744ef4ccdde86f46197a7da33e0053">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() * Up())&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the product of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00985">985</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() * Up())&gt;(pa) *= pb; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a45baf6731916a2509a6c7cecc7fe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a45baf6731916a2509a6c7cecc7fe79">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() * Up())&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Up &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the product of a polynomial with a scalar. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00937">937</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() * Up())&gt;(poly) *= x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aabff597754fb0244c190e91bb6f26fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabff597754fb0244c190e91bb6f26fd4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication operators... </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00241">241</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    {</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="keywordflow">return</span> x;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;      <span class="keywordflow">if</span> (y.index() == 0)</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">return</span> y;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        {</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;          <span class="keywordflow">if</span> (y.index() == 1)</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;1&gt;(x) * std::get&lt;1&gt;(y));</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;1&gt;(x) * std::get&lt;2&gt;(y));</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        }</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        {</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;          <span class="keywordflow">if</span> (y.index() == 1)</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;2&gt;(x) * std::get&lt;1&gt;(y));</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;2&gt;(x) * std::get&lt;2&gt;(y));</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        }</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a8d3aa3a28f77da8940fac42aff11d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8d3aa3a28f77da8940fac42aff11d4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00275">275</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#af5909d8b89e4fe1928b93a5be6f1058c">operator*</a>(x, Solution&lt;Real&gt;(y)); }</div>
<div class="ttc" id="anamespaceemsr_html_af5909d8b89e4fe1928b93a5be6f1058c"><div class="ttname"><a href="namespaceemsr.html#af5909d8b89e4fe1928b93a5be6f1058c">emsr::operator*</a></div><div class="ttdeci">constexpr Solution&lt; Real &gt; operator*(const std::complex&lt; Real &gt; &amp;x, const Solution&lt; Real &gt; &amp;y)</div><div class="ttdef"><b>Definition:</b> <a href="solution_8h_source.html#l00280">solution.h:280</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8a39231a5577174cc0db572a71551596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a39231a5577174cc0db572a71551596">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00265">265</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#af5909d8b89e4fe1928b93a5be6f1058c">operator*</a>(x, Solution&lt;Real&gt;(y)); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a16a7b09b354edaf1a67833b613a29fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a7b09b354edaf1a67833b613a29fe7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, Size&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the product of a polynomial with a scalar. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00688">688</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    { <span class="keywordflow">return</span> StaticPolynomial&lt;Tp, Size&gt;(poly) *= x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af5909d8b89e4fe1928b93a5be6f1058c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5909d8b89e4fe1928b93a5be6f1058c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00280">280</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#af5909d8b89e4fe1928b93a5be6f1058c">operator*</a>(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a685115a02fab5426320cb39202dc2103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685115a02fab5426320cb39202dc2103">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() * Up())&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00945">945</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() * Up())&gt;(x) *= poly; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15c299a6a1f67eea19cdd8efa945320c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c299a6a1f67eea19cdd8efa945320c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, Size&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00693">693</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    { <span class="keywordflow">return</span> StaticPolynomial&lt;Tp, Size&gt;(poly) *= x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a532d30a3725f3b9f83ff768947a20d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532d30a3725f3b9f83ff768947a20d2b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00270">270</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#af5909d8b89e4fe1928b93a5be6f1058c">operator*</a>(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaee7a79333f51a0708b40099b86c3d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee7a79333f51a0708b40099b86c3d68">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP+SizeQ - 1 &gt; emsr::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the product of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00746">746</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;    {</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;      StaticPolynomial&lt;Tp, P.degree() + Q.degree() + 1&gt; R;</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt;= P.degree(); ++i)</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        <span class="keywordflow">for</span> (std::size_t j = 0; j &lt;= Q.degree(); ++j)</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;          R[i + j] = P[i] * Q[j];</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;      <span class="keywordflow">return</span> R;</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac0950a02906dfd97c4e53b76021cdf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0950a02906dfd97c4e53b76021cdf79">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() + Up())&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00969">969</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() + Up())&gt;(pa) += pb; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a033506a4ee4ccdeec1d2d106715d063d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033506a4ee4ccdeec1d2d106715d063d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() + Up())&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Up &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum of a polynomial with a scalar. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00905">905</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() + Up())&gt;(poly) += x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0cc7606f0dde0b46384b29879ee9537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc7606f0dde0b46384b29879ee9537e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unary +/- </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00127">127</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    { <span class="keywordflow">return</span> x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b70158ac63e2c4ff91a23f962b10597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b70158ac63e2c4ff91a23f962b10597">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition operators... </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00147">147</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    {</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keywordflow">return</span> x;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;      <span class="keywordflow">if</span> (y.index() == 0)</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">return</span> y;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;          <span class="keywordflow">if</span> (y.index() == 1)</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;1&gt;(x) + std::get&lt;1&gt;(y));</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;1&gt;(x) + std::get&lt;2&gt;(y));</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        }</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;          <span class="keywordflow">if</span> (y.index() == 1)</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;2&gt;(x) + std::get&lt;1&gt;(y));</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;2&gt;(x) + std::get&lt;2&gt;(y));</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        }</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f1d6fe31e0864c5336cece2a58cdb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1d6fe31e0864c5336cece2a58cdb44">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00181">181</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#adf385890f1a6fa020b1773ba53d00310">operator+</a>(x, Solution&lt;Real&gt;(y)); }</div>
<div class="ttc" id="anamespaceemsr_html_adf385890f1a6fa020b1773ba53d00310"><div class="ttname"><a href="namespaceemsr.html#adf385890f1a6fa020b1773ba53d00310">emsr::operator+</a></div><div class="ttdeci">constexpr Solution&lt; Real &gt; operator+(const std::complex&lt; Real &gt; &amp;x, const Solution&lt; Real &gt; &amp;y)</div><div class="ttdef"><b>Definition:</b> <a href="solution_8h_source.html#l00186">solution.h:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afae0ae20027dc5a2044b9d6dd9534227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae0ae20027dc5a2044b9d6dd9534227">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00171">171</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#adf385890f1a6fa020b1773ba53d00310">operator+</a>(x, Solution&lt;Real&gt;(y)); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15f9c77d362616a5b91370c34a78fa6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f9c77d362616a5b91370c34a78fa6b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, Size&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum of a polynomial with a scalar. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00662">662</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    { <span class="keywordflow">return</span> StaticPolynomial&lt;Tp, Size&gt;(poly) += x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a63fc873d61e52834d706fdca83bfbb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc873d61e52834d706fdca83bfbb4c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, std::max(SizeP, SizeQ)&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00718">718</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    {</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;      <span class="keywordflow">if</span> constexpr (SizeP &gt;= SizeQ)</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;        {</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;          StaticPolynomial&lt;Tp, SizeP&gt; R = P;</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;          <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; SizeQ; ++i)</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;            R[i] += Q[i];</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;          <span class="keywordflow">return</span> R;</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;        }</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        <span class="keywordflow">return</span> Q + P;</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adf385890f1a6fa020b1773ba53d00310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf385890f1a6fa020b1773ba53d00310">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00186">186</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#adf385890f1a6fa020b1773ba53d00310">operator+</a>(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a403f7be9f19b8cd47e718d94ec8659c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403f7be9f19b8cd47e718d94ec8659c1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() + Up())&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00913">913</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() + Up())&gt;(x) += poly; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a69132b96f7e9a2ae23613329b9bc2c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69132b96f7e9a2ae23613329b9bc2c43">&#9670;&nbsp;</a></span>operator+() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, Size&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00667">667</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    { <span class="keywordflow">return</span> StaticPolynomial&lt;Tp, Size&gt;(poly) += x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab946e0e685c1304a6e9e249e837061a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab946e0e685c1304a6e9e249e837061a4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator+ </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00176">176</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#adf385890f1a6fa020b1773ba53d00310">operator+</a>(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a843a89e4dfe80c1548a59e70ac2f191c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843a89e4dfe80c1548a59e70ac2f191c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() - Up())&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00977">977</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() - Up())&gt;(pa) -= pb; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afeaf3b7d364a2f3d94396ea631702313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaf3b7d364a2f3d94396ea631702313">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() - Up())&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Up &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference of a polynomial with a scalar. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00921">921</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() - Up())&gt;(poly) -= x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a434a04338777c51fec03a803df64f1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434a04338777c51fec03a803df64f1ea">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00132">132</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    {</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keywordflow">return</span> x;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">return</span> Solution&lt;Real&gt;(-std::get&lt;1&gt;(x));</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">return</span> Solution&lt;Real&gt;(-std::get&lt;2&gt;(x));</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab571b1b9099153a1aba906a25e238dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab571b1b9099153a1aba906a25e238dfa">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction operators... </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00194">194</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keywordflow">return</span> x;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      <span class="keywordflow">if</span> (y.index() == 0)</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">return</span> y;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;          <span class="keywordflow">if</span> (y.index() == 1)</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;1&gt;(x) - std::get&lt;1&gt;(y));</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;1&gt;(x) - std::get&lt;2&gt;(y));</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        }</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;          <span class="keywordflow">if</span> (y.index() == 1)</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;2&gt;(x) - std::get&lt;1&gt;(y));</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;2&gt;(x) - std::get&lt;2&gt;(y));</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        }</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abb04a325d56ca7ee1ee8b4ced1a15800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb04a325d56ca7ee1ee8b4ced1a15800">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00228">228</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#af0e20c39abb723a3c8a6d6c81ad5b681">operator-</a>(x, Solution&lt;Real&gt;(y)); }</div>
<div class="ttc" id="anamespaceemsr_html_af0e20c39abb723a3c8a6d6c81ad5b681"><div class="ttname"><a href="namespaceemsr.html#af0e20c39abb723a3c8a6d6c81ad5b681">emsr::operator-</a></div><div class="ttdeci">constexpr Solution&lt; Real &gt; operator-(const std::complex&lt; Real &gt; &amp;x, const Solution&lt; Real &gt; &amp;y)</div><div class="ttdef"><b>Definition:</b> <a href="solution_8h_source.html#l00233">solution.h:233</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d0395812f51330c8690936c11f9a526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0395812f51330c8690936c11f9a526">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00218">218</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#af0e20c39abb723a3c8a6d6c81ad5b681">operator-</a>(x, Solution&lt;Real&gt;(y)); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a772477b7ef831939a073b26edba74ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772477b7ef831939a073b26edba74ceb">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, Size&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference of a polynomial with a scalar. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00675">675</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    { <span class="keywordflow">return</span> StaticPolynomial&lt;Tp, Size&gt;(poly) -= x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f90e5b35bca2c0e3c01acd3a2e454ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f90e5b35bca2c0e3c01acd3a2e454ae">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, std::max(SizeP, SizeQ)&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00737">737</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    { <span class="keywordflow">return</span> P + -Q; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af0e20c39abb723a3c8a6d6c81ad5b681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e20c39abb723a3c8a6d6c81ad5b681">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00233">233</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#af0e20c39abb723a3c8a6d6c81ad5b681">operator-</a>(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a615a0879331fef9a4b9af6175f8e938f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a0879331fef9a4b9af6175f8e938f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() - Up())&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00929">929</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() - Up())&gt;(x) -= poly; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aac3d0d3e888b0ad30918f438971124cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3d0d3e888b0ad30918f438971124cb">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, Size&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00680">680</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    { <span class="keywordflow">return</span> -StaticPolynomial&lt;Tp, Size&gt;(poly) += x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a016df2328f39b176fcd5c22f612497a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016df2328f39b176fcd5c22f612497a0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator- </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00223">223</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#af0e20c39abb723a3c8a6d6c81ad5b681">operator-</a>(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a20aabca53f527d2b4c2682e178ed8cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20aabca53f527d2b4c2682e178ed8cbf">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() / Up())&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the quotient of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00993">993</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() / Up())&gt;(pa) /= pb; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac256fc3b7f1798a6b95a612fd291bb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac256fc3b7f1798a6b95a612fd291bb4f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() / Up())&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Up &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the quotient of a polynomial with a scalar. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00953">953</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() / Up())&gt;(poly) /= x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae74c8d59cd3b187fc89692d21fb6aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae74c8d59cd3b187fc89692d21fb6aec">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>division operators... </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00288">288</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">return</span> x;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;      <span class="keywordflow">if</span> (y.index() == 0)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="keywordflow">return</span> y;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;          <span class="keywordflow">if</span> (y.index() == 1)</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;1&gt;(x) / std::get&lt;1&gt;(y));</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;1&gt;(x) / std::get&lt;2&gt;(y));</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        }</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;          <span class="keywordflow">if</span> (y.index() == 1)</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;2&gt;(x) / std::get&lt;1&gt;(y));</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::get&lt;2&gt;(x) / std::get&lt;2&gt;(y));</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        }</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b53a2571ed1de735c01abe73604730f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b53a2571ed1de735c01abe73604730f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00322">322</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a0151e61717cae6662ea239b3a2433d89">operator/</a>(x, Solution&lt;Real&gt;(y)); }</div>
<div class="ttc" id="anamespaceemsr_html_a0151e61717cae6662ea239b3a2433d89"><div class="ttname"><a href="namespaceemsr.html#a0151e61717cae6662ea239b3a2433d89">emsr::operator/</a></div><div class="ttdeci">constexpr Solution&lt; Real &gt; operator/(const std::complex&lt; Real &gt; &amp;x, const Solution&lt; Real &gt; &amp;y)</div><div class="ttdef"><b>Definition:</b> <a href="solution_8h_source.html#l00327">solution.h:327</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ddf836180b255c273560c94ba78aa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddf836180b255c273560c94ba78aa3e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00312">312</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a0151e61717cae6662ea239b3a2433d89">operator/</a>(x, Solution&lt;Real&gt;(y)); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae62b909a4cfa67f2023ae82816b150ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62b909a4cfa67f2023ae82816b150ba">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, Size&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the quotient of a polynomial with a scalar. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00701">701</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;    { <span class="keywordflow">return</span> StaticPolynomial&lt;Tp, Size&gt;(poly) /= x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0151e61717cae6662ea239b3a2433d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0151e61717cae6662ea239b3a2433d89">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00327">327</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a0151e61717cae6662ea239b3a2433d89">operator/</a>(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a65421cfb10c2b328c5f6fe32394e105a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65421cfb10c2b328c5f6fe32394e105a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , typename Up &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt;decltype(Tp() / Up())&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Tp &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Up &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the quotient of a scalar and a polynomials. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l01009">1009</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;    { <span class="keywordflow">return</span> Polynomial&lt;decltype(Tp() / Up())&gt;(x) /= poly; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0e523c350964ac38101a06d45484f65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e523c350964ac38101a06d45484f65a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00317">317</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a0151e61717cae6662ea239b3a2433d89">operator/</a>(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e1d926a861da466e01effa736d8a67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1d926a861da466e01effa736d8a67f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t SizeP, std::size_t SizeQ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt;Tp, <a class="el" href="structemsr_1_1divmod__t.html">divmod_t</a>&lt;Tp, SizeP, SizeQ&gt;::SizeQuo&gt; emsr::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeP &gt;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeQ &gt;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the quotient of two polynomials. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00793">793</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;    { <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#acef21b65838fd0c04b66d44127996289">divmod</a>(P, Q).quo; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a348aa4c91f5141addb4006973a934bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348aa4c91f5141addb4006973a934bd7">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lexicographic order of solutions as complex numbers. Null solutions compare as less than except to another null solution.</p>
<p>A tribool might be a good thing for this when either of the solutions is null. </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00403">403</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    {</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0 &amp;&amp; y.index() == 0)</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (y.index() == 0)</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        {</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> rex = <a class="code" href="namespaceemsr.html#a3b69f1c91fb3480e098db4e4bfe949f2">emsr::real</a>(x);</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> rey = <a class="code" href="namespaceemsr.html#a3b69f1c91fb3480e098db4e4bfe949f2">emsr::real</a>(y);</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;          <span class="keywordflow">if</span> (rex &lt; rey)</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rex == rey)</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a79ddc0cda81a11ab065e5caae9e0907a">emsr::imag</a>(x) &lt; <a class="code" href="namespaceemsr.html#a79ddc0cda81a11ab065e5caae9e0907a">emsr::imag</a>(y);</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        }</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    }</div>
<div class="ttc" id="anamespaceemsr_html_a3b69f1c91fb3480e098db4e4bfe949f2"><div class="ttname"><a href="namespaceemsr.html#a3b69f1c91fb3480e098db4e4bfe949f2">emsr::real</a></div><div class="ttdeci">constexpr Real real(const Solution&lt; Real &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="solution_8h_source.html#l00073">solution.h:73</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a651793a53daa6800efcd4d711b0dc8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651793a53daa6800efcd4d711b0dc8bf">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00436">436</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    { <span class="keywordflow">return</span> operator&lt;(x, Solution&lt;Real&gt;(y)); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1414352fb5db1523b704004efe6491e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1414352fb5db1523b704004efe6491e8">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00426">426</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    { <span class="keywordflow">return</span> operator&lt;(x, Solution&lt;Real&gt;(y)); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a59cee564d7a746ef2606609a28f90fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cee564d7a746ef2606609a28f90fa1">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00441">441</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    { <span class="keywordflow">return</span> operator&lt;(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a33f75a43bf27f6102ddef9ce53dfe4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f75a43bf27f6102ddef9ce53dfe4ab">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00431">431</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    { <span class="keywordflow">return</span> operator&lt;(Solution&lt;Real&gt;(x), y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a926f40da1c865e89a91b9f151c1e3346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926f40da1c865e89a91b9f151c1e3346">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;Char&gt;&amp; emsr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">emsr::Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>sln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output a solution to a stream. </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00441">441</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> idx = sln.index();</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;      <span class="keywordflow">if</span> (idx == 0)</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        out &lt;&lt; <span class="stringliteral">&quot;null&quot;</span>;</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (idx == 1)</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        out &lt;&lt; std::get&lt;1&gt;(sln);</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (idx == 2)</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;        out &lt;&lt; std::get&lt;2&gt;(sln);</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a138fa9753d495e1819e54d43d580720b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138fa9753d495e1819e54d43d580720b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; CharT, Traits &gt; &amp; emsr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a polynomial to a stream. The format is a parenthesized comma-delimited list of coefficients. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8tcc_source.html#l00385">385</a> of file <a class="el" href="polynomial_8tcc_source.html">polynomial.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    {</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;      <span class="keywordtype">int</span> old_prec = os.precision(std::numeric_limits&lt;Tp&gt;::max_digits10);</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;      os &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; poly.degree(); ++i)</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        os &lt;&lt; poly.coefficient(i) &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;      os &lt;&lt; poly.coefficient(poly.degree());</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;      os &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;      os.precision(old_prec);</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;      <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aefffa447e50d21ac578b5c3aafc992e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefffa447e50d21ac578b5c3aafc992e2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharT, Traits&gt;&amp; emsr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1RationalPolynomial.html">RationalPolynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a polynomial to a stream. The format is a parenthesized comma-delimited list of coefficients. </p>

<p class="definition">Definition at line <a class="el" href="rational__polynomial_8h_source.html#l00001">1</a> of file <a class="el" href="rational__polynomial_8h_source.html">rational_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      os &lt;&lt; poly.numer() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; poly.denom();</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a729181f523e75cde6b49162acf500eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729181f523e75cde6b49162acf500eb7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Tp , std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; CharT, Traits &gt; &amp; emsr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a polynomial to a stream. The format is a parenthesized comma-delimited list of coefficients. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8tcc_source.html#l00001">1</a> of file <a class="el" href="static__polynomial_8tcc_source.html">static_polynomial.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;      <span class="keywordtype">int</span> old_prec = os.precision(std::numeric_limits&lt;Tp&gt;::max_digits10);</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;      os &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; poly.degree(); ++i)</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        os &lt;&lt; poly.coefficient(i) &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      os &lt;&lt; poly.coefficient(poly.degree());</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;      os &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;      os.precision(old_prec);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;      <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab9f94cfb4f6d90681c4f279752b486a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f94cfb4f6d90681c4f279752b486a7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emsr::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if two polynomials are equal. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l01052">1052</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    { <span class="keywordflow">return</span> pa.m_coeff == pb.m_coeff; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a347cae7848e69cee8176eac10e5b9318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347cae7848e69cee8176eac10e5b9318">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test for equality and inequality. </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00335">335</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    {</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0 || y.index() == 0)</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == y.index())</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        {</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;          <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            <span class="keywordflow">return</span> std::get&lt;1&gt;(x) == std::get&lt;1&gt;(y);</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            <span class="keywordflow">return</span> std::get&lt;2&gt;(x) == std::get&lt;2&gt;(y);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        }</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8196fd2e8625f2b62cee678b1022a90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8196fd2e8625f2b62cee678b1022a90a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00362">362</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    { <span class="keywordflow">return</span> x == Solution&lt;Real&gt;(y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7319379b40a854772a1d399db164c920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7319379b40a854772a1d399db164c920">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emsr::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00352">352</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    { <span class="keywordflow">return</span> x == Solution&lt;Real&gt;(y); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a92f6814c1b9e0c05405223c667442a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f6814c1b9e0c05405223c667442a85">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00635">635</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    { <span class="keywordflow">return</span> pa.m_coeff == pb.m_coeff; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7358b909c9c8bab8309daf7357c4ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7358b909c9c8bab8309daf7357c4ac5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp , std::size_t SizeA, std::size_t SizeB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeA &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemsr_1_1StaticPolynomial.html">StaticPolynomial</a>&lt; Tp, SizeB &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if two polynomials are equal. </p>

<p class="definition">Definition at line <a class="el" href="static__polynomial_8h_source.html#l00629">629</a> of file <a class="el" href="static__polynomial_8h_source.html">static_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a392d7f9e0468d80cd6b8067a133d139e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392d7f9e0468d80cd6b8067a133d139e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00367">367</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    { <span class="keywordflow">return</span> Solution&lt;Real&gt;(x) == y; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e5d604182a149e63b319c13f72ccad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5d604182a149e63b319c13f72ccad3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emsr::operator== </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00357">357</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    { <span class="keywordflow">return</span> Solution&lt;Real&gt;(x) == y; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a93634c3102d6a9a883994cbd19c9cff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93634c3102d6a9a883994cbd19c9cff1">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; CharT, Traits &gt; &amp; emsr::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a polynomial from a stream. The input format can be a plain scalar (zero degree polynomial) or a parenthesized comma-delimited list of coefficients. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8tcc_source.html#l00436">436</a> of file <a class="el" href="polynomial_8tcc_source.html">polynomial.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    {</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;      Tp x;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;      CharT ch;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;      is &gt;&gt; ch;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;      <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;(&#39;</span>)</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        {</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;          <span class="keywordflow">do</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            {</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;              is &gt;&gt; x &gt;&gt; ch;</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;              poly.m_coeff.push_back(x);</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            }</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;          <span class="keywordflow">while</span> (ch == <span class="charliteral">&#39;,&#39;</span>);</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;          <span class="keywordflow">if</span> (ch != <span class="charliteral">&#39;)&#39;</span>)</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;            is.setstate(std::ios_base::failbit);</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        }</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        {</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;          is.putback(ch);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;          is &gt;&gt; x;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;          poly = x;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        }</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;      <span class="comment">// No null polynomial.</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      <span class="keywordflow">if</span> (poly.size() == 0)</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        poly.m_coeff.resize(1, Tp{});</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160; </div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;      <span class="keywordflow">return</span> is;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0fa608fda96ca8649cbdb86338e69846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa608fda96ca8649cbdb86338e69846">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;CharT, Traits&gt;&amp; emsr::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1RationalPolynomial.html">RationalPolynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a polynomial from a stream. The input format can be a plain scalar (zero degree polynomial) or a parenthesized comma-delimited list of coefficients. </p>

<p class="definition">Definition at line <a class="el" href="rational__polynomial_8h_source.html#l00216">216</a> of file <a class="el" href="rational__polynomial_8h_source.html">rational_polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      Polynomial&lt;Tp&gt; numer, denom;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      is &gt;&gt; numer;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      <span class="keywordflow">if</span> (!is.fail())</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;          CharT ch;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;          is &gt;&gt; ch;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;          <span class="keywordflow">if</span> (ch != <span class="charliteral">&#39;/&#39;</span>)</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            is.setstate(std::ios_base::failbit);</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            {</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;              is &gt;&gt; denom;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;              <span class="keywordflow">if</span> (!is.fail())</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                {</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                  poly.numer() = numer;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                  poly.denom() = denom;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                }</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            }</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        }</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;      <span class="keywordflow">return</span> is;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab1354c9f828ac3f5761e03435aabf136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1354c9f828ac3f5761e03435aabf136">&#9670;&nbsp;</a></span>quadratic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real , typename _Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt;, 2&gt; emsr::quadratic </td>
          <td>(</td>
          <td class="paramtype">const _Iter &amp;&#160;</td>
          <td class="paramname"><em>_CC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the roots of a quadratic equation of the form: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_2 x^2 + a_1 x + a_0 = 0 \]" src="form_6.png" width="110" height="15"/>
</p>
<p> for real coefficients <img class="formulaInl" alt="$ a_k $" src="form_7.png" width="11" height="9"/>.</p>
<p>For non-degenerate coefficients two roots are returned: Either the roots are real or the roots are a complex conjugate pair.</p>
<p>If the quadratic coefficient <img class="formulaInl" alt="$ a_2 $" src="form_8.png" width="11" height="9"/> is zero (degenerate case) at most one valid root is returned. If the linear coefficient <img class="formulaInl" alt="$ a_1 $" src="form_9.png" width="11" height="9"/> is also zero no valid root is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_CC</td><td>Array that contains the three coefficients of the quadratic equation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="solver__low__degree_8tcc_source.html#l00143">143</a> of file <a class="el" href="solver__low__degree_8tcc_source.html">solver_low_degree.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;      std::array&lt;Solution&lt;Real&gt;, 2&gt; _ZZ;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160; </div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      <span class="keywordflow">if</span> (_CC[2] == Real{0})</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        {</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;          <span class="comment">// Equation is linear (or completely degenerate).</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;          <span class="keywordflow">if</span> (_CC[1] == Real{0})</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            <span class="keywordflow">return</span> _ZZ;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;              _ZZ[0] = -_CC[0] / _CC[1];</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;              <span class="keywordflow">return</span> _ZZ;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            }</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        }</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_CC[0] == Real{0})</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;          _ZZ[0] = Real{0};</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;          <span class="keywordflow">if</span> (_CC[2] == Real{0})</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">return</span> _ZZ;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;              _ZZ[1] = -_CC[1] / _CC[2];</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;              <span class="keywordflow">return</span> _ZZ;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            }</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        {</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;          <span class="comment">// The discriminant of a quadratic equation</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> _QQ = _CC[1] * _CC[1] - Real{4} * _CC[2] * _CC[0];</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160; </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;          <span class="keywordflow">if</span> (_QQ &lt; Real{0})</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            {</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;              <span class="comment">// The roots are complex conjugates.</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;              <span class="keyword">const</span> <span class="keyword">auto</span> _ReZZ = -_CC[1] / (Real{2} * _CC[2]);</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;              <span class="keyword">const</span> <span class="keyword">auto</span> _ImZZ = std::sqrt(<a class="code" href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">std::abs</a>(_QQ)) / (Real{2} * _CC[2]);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;              _ZZ[0] = std::complex&lt;Real&gt;(_ReZZ, -_ImZZ);</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;              _ZZ[1] = std::complex&lt;Real&gt;(_ReZZ, _ImZZ);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            }</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;              <span class="comment">// The roots are real.</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;              Real temp = -(_CC[1]</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                        + std::copysign(std::sqrt(_QQ), _CC[1])) / Real{2};</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;              _ZZ[0] = temp / _CC[2];</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;              _ZZ[1] = _CC[0] / temp;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            }</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160; </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;      <span class="keywordflow">return</span> _ZZ;</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a00b524d40ae2c1c9a280df4408c8fed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b524d40ae2c1c9a280df4408c8fed2">&#9670;&nbsp;</a></span>quadratic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real , typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt;, 2&gt; emsr::quadratic </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>coef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2da681638d9a291cfbc004aac518e8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da681638d9a291cfbc004aac518e8ee">&#9670;&nbsp;</a></span>quadratic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt;, 2&gt; emsr::quadratic </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solver__low__degree_8h_source.html#l00062">62</a> of file <a class="el" href="solver__low__degree_8h_source.html">solver_low_degree.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;      <span class="keywordflow">return</span> quadratic&lt;Real&gt;(std::array&lt;Real, 3&gt;{c0, c1, c2});</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a822edeea9a631fdca6bd4634d67ee02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822edeea9a631fdca6bd4634d67ee02e">&#9670;&nbsp;</a></span>quartic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real , typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, 4 &gt; emsr::quartic </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>CC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the roots a quartic equation of the form: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_4 x^4 + a_3 x^3 + a_2 x^2 + a_1 x + a_0 = 0 \]" src="form_12.png" width="190" height="15"/>
</p>
<p> for real coefficients <img class="formulaInl" alt="$ a_k $" src="form_7.png" width="11" height="9"/>.</p>
<p>In the non-degenerate case there are four roots:</p><ul>
<li>All four roots are real</li>
<li>Two roots real and two complex roots are a complex conjugate pair</li>
<li>Four complex roots in two complex conjugate pairs</li>
</ul>
<p>If the qartic coefficient <img class="formulaInl" alt="$ a_4 $" src="form_13.png" width="11" height="9"/> is zero (degenerate case) the problem is referred to the cubic solver to return, at most, three valid roots.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CC</td><td>Array that contains the five(5) coefficients of the quartic equation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="solver__low__degree_8tcc_source.html#l00307">307</a> of file <a class="el" href="solver__low__degree_8tcc_source.html">solver_low_degree.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    {</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;      std::array&lt;Solution&lt;Real&gt;, 4&gt; ZZ;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160; </div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;      <span class="keywordflow">if</span> (CC[4] == Real{0})</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> ZZ3 = cubic&lt;Real&gt;(CC);</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;          ZZ[0] = ZZ3[0];</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;          ZZ[1] = ZZ3[1];</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;          ZZ[2] = ZZ3[2];</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        }</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CC[0] == Real{0})</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        {</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;          ZZ[0] = Real{0};</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> ZZ3 = cubic&lt;Real&gt;(CC[1], CC[2], CC[3], CC[4]);</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;          ZZ[1] = ZZ3[0];</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;          ZZ[2] = ZZ3[1];</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        }</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CC[3] == Real{0} &amp;&amp; CC[1] == Real{0})</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;          <span class="comment">// Solve the biquadratic equation.</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;          std::array&lt;Real, 3&gt; AA2{{CC[0], CC[2], CC[4]}};</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> ZZ2 = quadratic&lt;Real&gt;(AA2);</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;          <span class="keyword">auto</span> sqrt = [](Solution&lt;Real&gt; z) -&gt; Solution&lt;Real&gt;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                        {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                          <span class="keyword">const</span> <span class="keyword">auto</span> idx = z.index();</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                          <span class="keywordflow">if</span> (idx == 0)</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                            <span class="keywordflow">return</span> z;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (idx == 1)</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                            {</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                              <span class="keyword">auto</span> zz = std::get&lt;1&gt;(z);</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                              <span class="keywordflow">return</span> zz &lt; Real{0}</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                                   ? Solution&lt;Real&gt;(std::sqrt(std::complex&lt;Real&gt;(zz)))</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                                   : Solution&lt;Real&gt;(std::sqrt(zz));</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                            }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                            <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::sqrt(std::get&lt;2&gt;(z)));</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                        };</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;          ZZ[0] = sqrt(ZZ2[0]);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;          ZZ[1] = sqrt(ZZ2[1]);</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;          ZZ[2] = -ZZ[0];</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;          ZZ[3] = -ZZ[1];</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        }</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        {</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;          <span class="comment">// Normalize quartic equation coefficients.</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;          std::array&lt;Real, 5&gt; AA4;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;          AA4[4] = Real{1};</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;          AA4[3] = CC[3] / CC[4];</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;          AA4[2] = CC[2] / CC[4];</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;          AA4[1] = CC[1] / CC[4];</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;          AA4[0] = CC[0] / CC[4];</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160; </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;          <span class="comment">// Calculate the coefficients of the resolvent cubic equation.</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;          std::array&lt;Real, 4&gt; AA3;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;          AA3[3] = Real{1};</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;          AA3[2] = -AA4[2];</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;          AA3[1] = AA4[3] * AA4[1] - Real{4} * AA4[0];</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;          AA3[0] = AA4[0] * (Real{4} * AA4[2] - AA4[3] * AA4[3])</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                  - AA4[1] * AA4[1];</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160; </div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;          <span class="comment">// Find the algebraically largest real root of the cubic equation</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;          <span class="comment">// Note: A cubic equation has either three real roots or one</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;          <span class="comment">//       real root and two complex roots that are complex</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;          <span class="comment">//       conjugates. If there is only a single real root then</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;          <span class="comment">//       subroutine cubic always returns that single real root</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;          <span class="comment">//       (and therefore the algebraically largest real root of</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;          <span class="comment">//       the cubic equation) as root[0].</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;          Real Z3max;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;          <span class="keyword">auto</span> ZZ3 = cubic&lt;Real&gt;(AA3);</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;          <span class="keywordflow">if</span> (ZZ3[1].index() == 1 &amp;&amp; ZZ3[2].index() == 1)</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;              <span class="comment">// There is some horrible bug with swap and this variant.</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;              <span class="comment">// They may need to hold the same type.</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;              <span class="keywordflow">if</span> (ZZ3[0] &lt; ZZ3[1])</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                <span class="comment">//std::swap(ZZ3[0], ZZ3[1]);</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                {</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                  <span class="keyword">const</span> <span class="keyword">auto</span> tmp = ZZ3[0];</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;                  ZZ3[0] = ZZ3[1];</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                  ZZ3[1] = tmp;</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                }</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;              <span class="keywordflow">if</span> (ZZ3[0] &lt; ZZ3[2])</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                <span class="comment">//std::swap(ZZ3[0], ZZ3[2]);</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                {</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                  <span class="keyword">const</span> <span class="keyword">auto</span> tmp = ZZ3[0];</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                  ZZ3[0] = ZZ3[2];</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                  ZZ3[2] = tmp;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                }</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;              Z3max = std::get&lt;1&gt;(ZZ3[0]);</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            }</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            Z3max = std::get&lt;1&gt;(ZZ3[0]);</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160; </div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;          <span class="comment">// Calculate the coefficients for the two quadratic equations</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> capa = Real{0.5L} * AA4[3];</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> capb = Real{0.5L} * Z3max;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> capc = std::sqrt(capa * capa - AA4[2] + Z3max);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> capd = std::sqrt(capb * capb - AA4[0]);</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> cp = capa + capc;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> cm = capa - capc;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;          <span class="keyword">auto</span> dp = capb + capd;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;          <span class="keyword">auto</span> dm = capb - capd;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> t1 = cp * dm + cm * dp;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> t2 = cp * dp + cm * dm;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;          <span class="keywordflow">if</span> (<a class="code" href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">std::abs</a>(t2 - AA4[1]) &lt; <a class="code" href="namespaceemsr.html#a782d36096e8467b4a45a9dc2f89355b2">std::abs</a>(t1 - AA4[1]))</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;            <a class="code" href="namespaceemsr.html#a8b4e7f7636909dc8a88bc53d81f43eaf">std::swap</a>(dp, dm);</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160; </div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;          <span class="comment">// Coefficients for the first quadratic equation and find the roots.</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;          std::array&lt;Real, 3&gt; AA2;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;          AA2[2] = Real{1};</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;          AA2[1] = cp;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;          AA2[0] = dp;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> ZZ2p = quadratic&lt;Real&gt;(AA2);</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;          ZZ[0] = ZZ2p[0];</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;          ZZ[1] = ZZ2p[1];</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160; </div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;          <span class="comment">// Coefficients for the second quadratic equation and find the roots.</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;          AA2[2] = Real{1};</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;          AA2[1] = cm;</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;          AA2[0] = dm;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> ZZ2m = quadratic&lt;Real&gt;(AA2);</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;          ZZ[2] = ZZ2m[0];</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;          ZZ[3] = ZZ2m[1];</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        }</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160; </div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;      <span class="keywordflow">return</span> ZZ;</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    }</div>
<div class="ttc" id="anamespaceemsr_html_a8b4e7f7636909dc8a88bc53d81f43eaf"><div class="ttname"><a href="namespaceemsr.html#a8b4e7f7636909dc8a88bc53d81f43eaf">emsr::swap</a></div><div class="ttdeci">void swap(Polynomial&lt; Tp &gt; &amp;pa, Polynomial&lt; Tp &gt; &amp;pb) noexcept(noexcept(pa.swap(pb)))</div><div class="ttdef"><b>Definition:</b> <a href="polynomial_8h_source.html#l01068">polynomial.h:1068</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa267aed0e5f2d4e6b290d99dad0bb87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa267aed0e5f2d4e6b290d99dad0bb87f">&#9670;&nbsp;</a></span>quartic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt;, 4&gt; emsr::quartic </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>c4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solver__low__degree_8h_source.html#l00084">84</a> of file <a class="el" href="solver__low__degree_8h_source.html">solver_low_degree.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      <span class="keywordflow">return</span> quartic&lt;Real&gt;(std::array&lt;Real, 5&gt;{c0, c1, c2, c3, c4});</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a328968ec7874ae8890a1d673aa9b1410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328968ec7874ae8890a1d673aa9b1410">&#9670;&nbsp;</a></span>quot() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#a3ddbab71ecfa506ad878ac9e60153a02">quot_t</a> emsr::quot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bcdfe8ff564fe89c342ca83fbe5477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcdfe8ff564fe89c342ca83fbe5477c">&#9670;&nbsp;</a></span>quot() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#a858cd87acb34606af0ecef15aaae7db9">lquot_t</a> emsr::quot </td>
          <td>(</td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc0e06e608d1d96388610dc17e52c43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0e06e608d1d96388610dc17e52c43f">&#9670;&nbsp;</a></span>quot() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#a7c6dbac674a6a512a5cbd904d8e6ba10">llquot_t</a> emsr::quot </td>
          <td>(</td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac087677b513a944eb60e5df77309a8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac087677b513a944eb60e5df77309a8df">&#9670;&nbsp;</a></span>quot() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#a8e7689491743dc22cc5ad3ed13245199">squot_t</a> emsr::quot </td>
          <td>(</td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a864f68f8b3af8302e1ef49e2e7c7cda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864f68f8b3af8302e1ef49e2e7c7cda6">&#9670;&nbsp;</a></span>quot() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#ab11381c9f569c2c3d6ea24d63fbca345">intmaxquot_t</a> emsr::quot </td>
          <td>(</td>
          <td class="paramtype">std::intmax_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::intmax_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b69f1c91fb3480e098db4e4bfe949f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b69f1c91fb3480e098db4e4bfe949f2">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Real emsr::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00073">73</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordflow">return</span> std::numeric_limits&lt;Real&gt;::quiet_NaN();</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        <span class="keywordflow">return</span> std::get&lt;1&gt;(x);</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceemsr.html#a3b69f1c91fb3480e098db4e4bfe949f2">std::real</a>(std::get&lt;2&gt;(x));</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aac71b8e58e2db0192f8d87514170f8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac71b8e58e2db0192f8d87514170f8c3">&#9670;&nbsp;</a></span>refine_solution_halley() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t _Dim, typename _Iter , typename _NumTp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_NumTp emsr::refine_solution_halley </td>
          <td>(</td>
          <td class="paramtype">_NumTp&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Iter &amp;&#160;</td>
          <td class="paramname"><em>_CC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine a solution using the Halley method: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{n+1} - x_n = -\frac{2 P(x_n) P'(x_n)} {2 [P'(x_n)]^2 - P(x_n) P''(x_n)} \]" src="form_4.png" width="228" height="31"/>
</p>
<p> This form indicates the close relationship to the Newton method: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{n+1} - x_n = -\frac{P'(x_n)} {P'(x_n) - [P(x_n) P''(x_n)]/[2P'(x_n)]} \]" src="form_5.png" width="273" height="31"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="solver__low__degree_8tcc_source.html#l00084">84</a> of file <a class="el" href="solver__low__degree_8tcc_source.html">solver_low_degree.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;          <span class="keyword">auto</span> f = _NumTp(_CC[_Dim - 1]);</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = _Dim - 1; j &gt; 0; --j)</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            f = _NumTp(_CC[j - 1]) + z * f;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160; </div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;          <span class="keyword">auto</span> df = _NumTp((_Dim - 1) * _CC[_Dim - 1]);</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = _Dim - 1; j &gt; 1; --j)</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            df = _NumTp((j - 1) * _CC[j - 1]) + z * df;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160; </div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;          <span class="keyword">auto</span> d2f = _NumTp((_Dim - 2) * (_Dim - 1) * _CC[_Dim - 1]);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = _Dim - 1; j &gt; 2; --j)</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            d2f = _NumTp((j - 2) * (j - 1) * _CC[j - 1]) + z * d2f;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160; </div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> del = _NumTp{2} * f * df</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                           / (_NumTp{2} * df * df - f * d2f);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160; </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;          z -= del;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        }</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      <span class="keywordflow">return</span> z;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa39848f35781685f7348bd000d4c8f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39848f35781685f7348bd000d4c8f04">&#9670;&nbsp;</a></span>refine_solution_halley() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dim, typename Iter , typename NumTp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumTp emsr::refine_solution_halley </td>
          <td>(</td>
          <td class="paramtype">NumTp&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>CC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a771083ec16ae63a6c0a545c7bef25d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771083ec16ae63a6c0a545c7bef25d9a">&#9670;&nbsp;</a></span>refine_solution_newton() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t _Dim, typename _Iter , typename _NumTp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_NumTp emsr::refine_solution_newton </td>
          <td>(</td>
          <td class="paramtype">_NumTp&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Iter &amp;&#160;</td>
          <td class="paramname"><em>_CC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine a solution using the Newton method: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{n+1} - x_n = -\frac{P(x_n)}{P'(x_n)} \]" src="form_3.png" width="121" height="31"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="solver__low__degree_8tcc_source.html#l00052">52</a> of file <a class="el" href="solver__low__degree_8tcc_source.html">solver_low_degree.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        {</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;          <span class="keyword">auto</span> f = _NumTp(_CC[_Dim - 1]);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = _Dim - 1; j &gt; 0; --j)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            f = _NumTp(_CC[j - 1]) + z * f;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160; </div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;          <span class="keyword">auto</span> df = _NumTp((_Dim - 1) * _CC[_Dim - 1]);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = _Dim - 1; j &gt; 1; --j)</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            df = _NumTp((j - 1) * _CC[j - 1]) + z * df;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> del = f / df;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;          z -= del;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      <span class="keywordflow">return</span> z;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c391643349e3d33d22c04af7e639e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c391643349e3d33d22c04af7e639e59">&#9670;&nbsp;</a></span>refine_solution_newton() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dim, typename Iter , typename NumTp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumTp emsr::refine_solution_newton </td>
          <td>(</td>
          <td class="paramtype">NumTp&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>CC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbb77296ece59944a997721abe25c58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb77296ece59944a997721abe25c58a">&#9670;&nbsp;</a></span>refine_solutions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t _Dim, typename _Iter , typename Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emsr::refine_solutions </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt;, _Dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_ZZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Iter &amp;&#160;</td>
          <td class="paramname"><em>_CC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solver__low__degree_8tcc_source.html#l00110">110</a> of file <a class="el" href="solver__low__degree_8tcc_source.html">solver_low_degree.tcc</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; _Dim - 1; ++i)</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        {</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;          <span class="keywordflow">if</span> (_ZZ[i].index() == 0)</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_ZZ[i].index() == 1)</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            _ZZ[i] = refine_solution_newton&lt;_Dim&gt;(std::get&lt;1&gt;(_ZZ[i]), _CC);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_ZZ[i].index() == 2)</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            _ZZ[i] = refine_solution_newton&lt;_Dim&gt;(std::get&lt;2&gt;(_ZZ[i]), _CC);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        }</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af587fd280f06e9ece8a65d17b94951fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af587fd280f06e9ece8a65d17b94951fb">&#9670;&nbsp;</a></span>remquo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt;double&gt; emsr::remquo </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afff207b997391cf05f4fe14aa23d5302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff207b997391cf05f4fe14aa23d5302">&#9670;&nbsp;</a></span>remquo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt;float&gt; emsr::remquo </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cf92d848c3dc6a420b3bc5052fd0e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf92d848c3dc6a420b3bc5052fd0e5f">&#9670;&nbsp;</a></span>remquo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt;long double&gt; emsr::remquo </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67c31c647ef9dd9dd717fe042d207fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c31c647ef9dd9dd717fe042d207fad">&#9670;&nbsp;</a></span>remquof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt;float&gt; emsr::remquof </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b3f01d2d56357ae6e6b9425534e8316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3f01d2d56357ae6e6b9425534e8316">&#9670;&nbsp;</a></span>remquol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1remquo__t.html">remquo_t</a>&lt;long double&gt; emsr::remquol </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61f461846493fb75c010254d3486e6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f461846493fb75c010254d3486e6d5">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp emsr::sign </td>
          <td>(</td>
          <td class="paramtype">Tp&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00431">431</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    { <span class="keywordflow">return</span> Tp(x &lt; 0 ? -1 : -1); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aefee9f0dea81a2a28f122bd1c8535fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefee9f0dea81a2a28f122bd1c8535fbd">&#9670;&nbsp;</a></span>signum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp emsr::signum </td>
          <td>(</td>
          <td class="paramtype">Tp&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="notsospecfun_8h_source.html#l00437">437</a> of file <a class="el" href="notsospecfun_8h_source.html">notsospecfun.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    { <span class="keywordflow">return</span> Tp(x == 0 ? 0 : x &lt; 0 ? -1 : -1); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8191598409fa9366baf28c5aa39928d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8191598409fa9366baf28c5aa39928d3">&#9670;&nbsp;</a></span>squot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemsr.html#a8e7689491743dc22cc5ad3ed13245199">squot_t</a> emsr::squot </td>
          <td>(</td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b4e7f7636909dc8a88bc53d81f43eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4e7f7636909dc8a88bc53d81f43eaf">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emsr::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemsr_1_1Polynomial.html">Polynomial</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="classemsr_1_1Polynomial.html#a1ecd2d2165aa049559c5487d65b2ebdf">Polynomial::swap()</a>. </p>

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l01068">1068</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;    { pa.swap(pb); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a31fe15f97bf442f3b709d901904a5c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fe15f97bf442f3b709d901904a5c72">&#9670;&nbsp;</a></span>to_complex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt;Real&gt; emsr::to_complex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemsr_1_1Solution.html">Solution</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the solution as a complex number or NaN. </p>

<p class="definition">Definition at line <a class="el" href="solution_8h_source.html#l00112">112</a> of file <a class="el" href="solution_8h_source.html">solution.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    {</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;      <span class="keywordflow">if</span> (x.index() == 0)</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordflow">return</span> Solution&lt;Real&gt;();</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x.index() == 1)</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="keywordflow">return</span> Solution&lt;Real&gt;(std::complex&lt;Real&gt;(std::get&lt;1&gt;(x)));</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">return</span> x;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5bf2c62dcc64e44b8b65766f71d8aa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf2c62dcc64e44b8b65766f71d8aa64">&#9670;&nbsp;</a></span>has_imag_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emsr::has_imag_v = <a class="el" href="structemsr_1_1has__imag__t.html">has_imag_t</a>&lt;Tp&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00093">93</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>

</div>
</div>
<a id="a59e13ee841ec1f2dbfb09ed021036d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e13ee841ec1f2dbfb09ed021036d3a">&#9670;&nbsp;</a></span>has_value_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emsr::has_value_type_v = <a class="el" href="structemsr_1_1has__value__type__t.html">has_value_type_t</a>&lt;Tp&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="polynomial_8h_source.html#l00107">107</a> of file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceemsr.html">emsr</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
